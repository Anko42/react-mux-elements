{
  "version": 3,
  "sources": ["../src/index.tsx", "../../../node_modules/@mux/upchunk/node_modules/global/window.js", "../../../node_modules/@mux/upchunk/node_modules/is-function/index.js", "../../../node_modules/@mux/upchunk/node_modules/parse-headers/parse-headers.js", "../../../node_modules/@mux/upchunk/node_modules/xtend/immutable.js", "../../../node_modules/@mux/upchunk/node_modules/xhr/index.js", "../../../node_modules/@mux/upchunk/node_modules/src/lib/misc.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/error-handler.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/global.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/warning-handler.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/warnings.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/event.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/dom-exception.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/event-wrapper.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/listener.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/listener-list.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/listener-list-map.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/event-target.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/event-attribute-handler.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/legacy.ts", "../../../node_modules/@mux/upchunk/src/upchunk.ts", "../../../shared/polyfills/index.js", "../../mux-uploader/src/mux-uploader-drop.ts", "../../mux-uploader/src/index.ts", "../src/mux-uploader-drop.tsx", "../src/common/utils.ts", "../src/useCombinedRefs.ts", "../src/useObjectPropEffect.ts"],
  "sourcesContent": ["import React, { useEffect } from 'react';\nimport type { CSSProperties } from 'react';\nimport '@mux/mux-uploader';\nimport MuxUploaderDrop from './mux-uploader-drop';\nimport type MuxUploaderElement from '@mux/mux-uploader';\nimport type { MuxUploaderElementEventMap } from '@mux/mux-uploader';\nimport { toNativeProps } from './common/utils';\nimport { useRef } from 'react';\nimport { useCombinedRefs } from './useCombinedRefs';\nimport useObjectPropEffect from './useObjectPropEffect';\n\nexport type MuxUploaderRefAttributes = MuxUploaderElement;\n\ninterface GenericEventListener<T extends Event = CustomEvent> {\n  (evt: T): void;\n}\n\nexport type MuxUploaderProps = {\n  id?: string;\n  endpoint?: MuxUploaderElement['endpoint'];\n  type?: string;\n  status?: boolean;\n  style?: CSSProperties & {\n    ['--uploader-font-family']?: CSSProperties['fontFamily'];\n    ['--uploader-font-size']?: CSSProperties['fontSize'];\n    ['--uploader-background-color']?: CSSProperties['backgroundColor'];\n    ['--button-background-color']?: CSSProperties['backgroundColor'];\n    ['--button-border-radius']?: CSSProperties['borderRadius'];\n    ['--button-border']?: CSSProperties['border'];\n    ['--button-padding']?: CSSProperties['padding'];\n    ['--button-hover-text']?: CSSProperties['color'];\n    ['--button-hover-background']?: CSSProperties['background'];\n    ['--button-active-text']?: CSSProperties['color'];\n    ['--button-active-background']?: CSSProperties['background'];\n    ['--progress-bar-fill-color']?: CSSProperties['background'];\n    ['--progress-radial-fill-color']?: CSSProperties['stroke'];\n  };\n  children?: React.ReactNode;\n  formatProgress?: (percent: number) => string;\n  dynamicChunkSize?: boolean;\n  onUploadStart?: GenericEventListener<MuxUploaderElementEventMap['uploadstart']>;\n  onChunkAttempt?: GenericEventListener<MuxUploaderElementEventMap['chunkattempt']>;\n  onChunkSuccess?: GenericEventListener<MuxUploaderElementEventMap['chunksuccess']>;\n  onUploadError?: GenericEventListener<MuxUploaderElementEventMap['uploaderror']>;\n  onProgress?: GenericEventListener<MuxUploaderElementEventMap['progress']>;\n  onSuccess?: GenericEventListener<MuxUploaderElementEventMap['success']>;\n} & Omit<React.DetailedHTMLProps<React.HTMLAttributes<HTMLElement>, HTMLElement>, 'ref'>;\n\nconst MuxUploaderInternal = React.forwardRef<MuxUploaderRefAttributes, MuxUploaderProps>(\n  ({ children, ...props }, ref) => {\n    return React.createElement('mux-uploader', toNativeProps({ ...props, ref }), children);\n  }\n);\n\nconst useEventCallbackEffect = <K extends keyof MuxUploaderElementEventMap>(\n  type: K,\n  ref: // | ((instance: EventTarget | null) => void)\n  React.MutableRefObject<MuxUploaderElement | null> | null | undefined,\n  callback: GenericEventListener<MuxUploaderElementEventMap[K]> | undefined\n) => {\n  return useEffect(() => {\n    const eventTarget = ref?.current;\n    if (!eventTarget || !callback) return;\n    eventTarget.addEventListener(type, callback);\n    return () => {\n      eventTarget.removeEventListener(type, callback);\n    };\n  }, [ref?.current, callback]);\n};\n\nconst useUploader = (\n  ref: // | ((instance: EventTarget | null) => void)\n  React.MutableRefObject<MuxUploaderElement | null> | null | undefined,\n  props: MuxUploaderProps\n) => {\n  const {\n    onUploadStart,\n    onChunkAttempt,\n    onChunkSuccess,\n    onUploadError,\n    onProgress,\n    onSuccess,\n    formatProgress,\n    endpoint,\n    ...remainingProps\n  } = props;\n  useObjectPropEffect('endpoint', endpoint, ref);\n  useObjectPropEffect('formatProgress', formatProgress, ref);\n  useEventCallbackEffect('uploadstart', ref, onUploadStart);\n  useEventCallbackEffect('chunkattempt', ref, onChunkAttempt);\n  useEventCallbackEffect('chunksuccess', ref, onChunkSuccess);\n  useEventCallbackEffect('uploaderror', ref, onUploadError);\n  useEventCallbackEffect('progress', ref, onProgress);\n  useEventCallbackEffect('success', ref, onSuccess);\n  return [remainingProps];\n};\n\nconst MuxUploader = React.forwardRef<MuxUploaderRefAttributes, MuxUploaderProps>((props, ref) => {\n  const innerUploaderRef = useRef<MuxUploaderElement>(null);\n  const uploaderRef = useCombinedRefs(innerUploaderRef, ref);\n  const [remainingProps] = useUploader(innerUploaderRef, props);\n\n  return <MuxUploaderInternal ref={uploaderRef as typeof innerUploaderRef} {...remainingProps} />;\n});\n\nexport { MuxUploaderDrop };\n\nexport default MuxUploader;\n", "var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n", "module.exports = isFunction\n\nvar toString = Object.prototype.toString\n\nfunction isFunction (fn) {\n  if (!fn) {\n    return false\n  }\n  var string = toString.call(fn)\n  return string === '[object Function]' ||\n    (typeof fn === 'function' && string !== '[object RegExp]') ||\n    (typeof window !== 'undefined' &&\n     // IE8 and below\n     (fn === window.setTimeout ||\n      fn === window.alert ||\n      fn === window.confirm ||\n      fn === window.prompt))\n};\n", "var trim = function(string) {\n  return string.replace(/^\\s+|\\s+$/g, '');\n}\n  , isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    }\n\nmodule.exports = function (headers) {\n  if (!headers)\n    return {}\n\n  var result = {}\n\n  var headersArr = trim(headers).split('\\n')\n\n  for (var i = 0; i < headersArr.length; i++) {\n    var row = headersArr[i]\n    var index = row.indexOf(':')\n    , key = trim(row.slice(0, index)).toLowerCase()\n    , value = trim(row.slice(index + 1))\n\n    if (typeof(result[key]) === 'undefined') {\n      result[key] = value\n    } else if (isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [ result[key], value ]\n    }\n  }\n\n  return result\n}\n", "module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n", "\"use strict\";\nvar window = require(\"global/window\")\nvar isFunction = require(\"is-function\")\nvar parseHeaders = require(\"parse-headers\")\nvar xtend = require(\"xtend\")\n\nmodule.exports = createXHR\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = createXHR;\ncreateXHR.XMLHttpRequest = window.XMLHttpRequest || noop\ncreateXHR.XDomainRequest = \"withCredentials\" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest\n\nforEachArray([\"get\", \"put\", \"post\", \"patch\", \"head\", \"delete\"], function(method) {\n    createXHR[method === \"delete\" ? \"del\" : method] = function(uri, options, callback) {\n        options = initParams(uri, options, callback)\n        options.method = method.toUpperCase()\n        return _createXHR(options)\n    }\n})\n\nfunction forEachArray(array, iterator) {\n    for (var i = 0; i < array.length; i++) {\n        iterator(array[i])\n    }\n}\n\nfunction isEmpty(obj){\n    for(var i in obj){\n        if(obj.hasOwnProperty(i)) return false\n    }\n    return true\n}\n\nfunction initParams(uri, options, callback) {\n    var params = uri\n\n    if (isFunction(options)) {\n        callback = options\n        if (typeof uri === \"string\") {\n            params = {uri:uri}\n        }\n    } else {\n        params = xtend(options, {uri: uri})\n    }\n\n    params.callback = callback\n    return params\n}\n\nfunction createXHR(uri, options, callback) {\n    options = initParams(uri, options, callback)\n    return _createXHR(options)\n}\n\nfunction _createXHR(options) {\n    if(typeof options.callback === \"undefined\"){\n        throw new Error(\"callback argument missing\")\n    }\n\n    var called = false\n    var callback = function cbOnce(err, response, body){\n        if(!called){\n            called = true\n            options.callback(err, response, body)\n        }\n    }\n\n    function readystatechange() {\n        if (xhr.readyState === 4) {\n            setTimeout(loadFunc, 0)\n        }\n    }\n\n    function getBody() {\n        // Chrome with requestType=blob throws errors arround when even testing access to responseText\n        var body = undefined\n\n        if (xhr.response) {\n            body = xhr.response\n        } else {\n            body = xhr.responseText || getXml(xhr)\n        }\n\n        if (isJson) {\n            try {\n                body = JSON.parse(body)\n            } catch (e) {}\n        }\n\n        return body\n    }\n\n    function errorFunc(evt) {\n        clearTimeout(timeoutTimer)\n        if(!(evt instanceof Error)){\n            evt = new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\") )\n        }\n        evt.statusCode = 0\n        return callback(evt, failureResponse)\n    }\n\n    // will load the data & process the response in a special response object\n    function loadFunc() {\n        if (aborted) return\n        var status\n        clearTimeout(timeoutTimer)\n        if(options.useXDR && xhr.status===undefined) {\n            //IE8 CORS GET successful response doesn't have a status field, but body is fine\n            status = 200\n        } else {\n            status = (xhr.status === 1223 ? 204 : xhr.status)\n        }\n        var response = failureResponse\n        var err = null\n\n        if (status !== 0){\n            response = {\n                body: getBody(),\n                statusCode: status,\n                method: method,\n                headers: {},\n                url: uri,\n                rawRequest: xhr\n            }\n            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE\n                response.headers = parseHeaders(xhr.getAllResponseHeaders())\n            }\n        } else {\n            err = new Error(\"Internal XMLHttpRequest Error\")\n        }\n        return callback(err, response, response.body)\n    }\n\n    var xhr = options.xhr || null\n\n    if (!xhr) {\n        if (options.cors || options.useXDR) {\n            xhr = new createXHR.XDomainRequest()\n        }else{\n            xhr = new createXHR.XMLHttpRequest()\n        }\n    }\n\n    var key\n    var aborted\n    var uri = xhr.url = options.uri || options.url\n    var method = xhr.method = options.method || \"GET\"\n    var body = options.body || options.data\n    var headers = xhr.headers = options.headers || {}\n    var sync = !!options.sync\n    var isJson = false\n    var timeoutTimer\n    var failureResponse = {\n        body: undefined,\n        headers: {},\n        statusCode: 0,\n        method: method,\n        url: uri,\n        rawRequest: xhr\n    }\n\n    if (\"json\" in options && options.json !== false) {\n        isJson = true\n        headers[\"accept\"] || headers[\"Accept\"] || (headers[\"Accept\"] = \"application/json\") //Don't override existing accept header declared by user\n        if (method !== \"GET\" && method !== \"HEAD\") {\n            headers[\"content-type\"] || headers[\"Content-Type\"] || (headers[\"Content-Type\"] = \"application/json\") //Don't override existing accept header declared by user\n            body = JSON.stringify(options.json === true ? body : options.json)\n        }\n    }\n\n    xhr.onreadystatechange = readystatechange\n    xhr.onload = loadFunc\n    xhr.onerror = errorFunc\n    // IE9 must have onprogress be set to a unique function.\n    xhr.onprogress = function () {\n        // IE must die\n    }\n    xhr.onabort = function(){\n        aborted = true;\n    }\n    xhr.ontimeout = errorFunc\n    xhr.open(method, uri, !sync, options.username, options.password)\n    //has to be after open\n    if(!sync) {\n        xhr.withCredentials = !!options.withCredentials\n    }\n    // Cannot set timeout with sync request\n    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\n    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\n    if (!sync && options.timeout > 0 ) {\n        timeoutTimer = setTimeout(function(){\n            if (aborted) return\n            aborted = true//IE9 may still call readystatechange\n            xhr.abort(\"timeout\")\n            var e = new Error(\"XMLHttpRequest timeout\")\n            e.code = \"ETIMEDOUT\"\n            errorFunc(e)\n        }, options.timeout )\n    }\n\n    if (xhr.setRequestHeader) {\n        for(key in headers){\n            if(headers.hasOwnProperty(key)){\n                xhr.setRequestHeader(key, headers[key])\n            }\n        }\n    } else if (options.headers && !isEmpty(options.headers)) {\n        throw new Error(\"Headers cannot be set on an XDomainRequest object\")\n    }\n\n    if (\"responseType\" in options) {\n        xhr.responseType = options.responseType\n    }\n\n    if (\"beforeSend\" in options &&\n        typeof options.beforeSend === \"function\"\n    ) {\n        options.beforeSend(xhr)\n    }\n\n    // Microsoft Edge browser sends \"undefined\" when send is called with undefined value.\n    // XMLHttpRequest spec says to pass null as body to indicate no body\n    // See https://github.com/naugtur/xhr/issues/100.\n    xhr.send(body || null)\n\n    return xhr\n\n\n}\n\nfunction getXml(xhr) {\n    // xhr.responseXML will throw Exception \"InvalidStateError\" or \"DOMException\"\n    // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.\n    try {\n        if (xhr.responseType === \"document\") {\n            return xhr.responseXML\n        }\n        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === \"parsererror\"\n        if (xhr.responseType === \"\" && !firefoxBugTakenEffect) {\n            return xhr.responseXML\n        }\n    } catch (e) {}\n\n    return null\n}\n\nfunction noop() {}\n", "/**\n * Assert a condition.\n * @param condition The condition that it should satisfy.\n * @param message The error message.\n * @param args The arguments for replacing placeholders in the message.\n */\nexport function assertType(\n    condition: boolean,\n    message: string,\n    ...args: any[]\n): asserts condition {\n    if (!condition) {\n        throw new TypeError(format(message, args))\n    }\n}\n\n/**\n * Convert a text and arguments to one string.\n * @param message The formating text\n * @param args The arguments.\n */\nexport function format(message: string, args: any[]): string {\n    let i = 0\n    return message.replace(/%[os]/gu, () => anyToString(args[i++]))\n}\n\n/**\n * Convert a value to a string representation.\n * @param x The value to get the string representation.\n */\nexport function anyToString(x: any): string {\n    if (typeof x !== \"object\" || x === null) {\n        return String(x)\n    }\n    return Object.prototype.toString.call(x)\n}\n", "import { anyToString, assertType } from \"./misc\"\n\ndeclare const console: any\ndeclare const dispatchEvent: any\ndeclare const ErrorEvent: any\ndeclare const process: any\n\nlet currentErrorHandler: setErrorHandler.ErrorHandler | undefined\n\n/**\n * Set the error handler.\n * @param value The error handler to set.\n */\nexport function setErrorHandler(\n    value: setErrorHandler.ErrorHandler | undefined,\n): void {\n    assertType(\n        typeof value === \"function\" || value === undefined,\n        \"The error handler must be a function or undefined, but got %o.\",\n        value,\n    )\n    currentErrorHandler = value\n}\nexport namespace setErrorHandler {\n    /**\n     * The error handler.\n     * @param error The thrown error object.\n     */\n    export type ErrorHandler = (error: Error) => void\n}\n\n/**\n * Print a error message.\n * @param maybeError The error object.\n */\nexport function reportError(maybeError: unknown): void {\n    try {\n        const error =\n            maybeError instanceof Error\n                ? maybeError\n                : new Error(anyToString(maybeError))\n\n        // Call the user-defined error handler if exists.\n        if (currentErrorHandler) {\n            currentErrorHandler(error)\n            return\n        }\n\n        // Dispatch an `error` event if this is on a browser.\n        if (\n            typeof dispatchEvent === \"function\" &&\n            typeof ErrorEvent === \"function\"\n        ) {\n            dispatchEvent(\n                new ErrorEvent(\"error\", { error, message: error.message }),\n            )\n        }\n\n        // Emit an `uncaughtException` event if this is on Node.js.\n        //istanbul ignore else\n        else if (\n            typeof process !== \"undefined\" &&\n            typeof process.emit === \"function\"\n        ) {\n            process.emit(\"uncaughtException\", error)\n            return\n        }\n\n        // Otherwise, print the error.\n        console.error(error)\n    } catch {\n        // ignore.\n    }\n}\n", "declare const globalThis: any\ndeclare const window: any\ndeclare const self: any\ndeclare const global: any\n\n/**\n * The global object.\n */\n//istanbul ignore next\nexport const Global: any =\n    typeof window !== \"undefined\"\n        ? window\n        : typeof self !== \"undefined\"\n        ? self\n        : typeof global !== \"undefined\"\n        ? global\n        : typeof globalThis !== \"undefined\"\n        ? globalThis\n        : undefined\n", "import { assertType } from \"./misc\"\n\ndeclare const console: any\n\nlet currentWarnHandler: setWarningHandler.WarningHandler | undefined\n\n/**\n * Set the warning handler.\n * @param value The warning handler to set.\n */\nexport function setWarningHandler(\n    value: setWarningHandler.WarningHandler | undefined,\n): void {\n    assertType(\n        typeof value === \"function\" || value === undefined,\n        \"The warning handler must be a function or undefined, but got %o.\",\n        value,\n    )\n    currentWarnHandler = value\n}\nexport namespace setWarningHandler {\n    /**\n     * The warning information.\n     */\n    export interface Warning {\n        /**\n         * The code of this warning.\n         */\n        code: string\n        /**\n         * The message in English.\n         */\n        message: string\n        /**\n         * The arguments for replacing placeholders in the text.\n         */\n        args: any[]\n    }\n\n    /**\n     * The warning handler.\n     * @param warning The warning.\n     */\n    export type WarningHandler = (warning: Warning) => void\n}\n\n/**\n * The warning information.\n */\nexport class Warning<TArgs extends any[]> {\n    readonly code: string\n    readonly message: string\n\n    constructor(code: string, message: string) {\n        this.code = code\n        this.message = message\n    }\n\n    /**\n     * Report this warning.\n     * @param args The arguments of the warning.\n     */\n    warn(...args: TArgs): void {\n        try {\n            // Call the user-defined warning handler if exists.\n            if (currentWarnHandler) {\n                currentWarnHandler({ ...this, args })\n                return\n            }\n\n            // Otherwise, print the warning.\n            const stack = (new Error().stack ?? \"\").replace(\n                /^(?:.+?\\n){2}/gu,\n                \"\\n\",\n            )\n            console.warn(this.message, ...args, stack)\n        } catch {\n            // Ignore.\n        }\n    }\n}\n", "import { EventTarget } from \"./event-target\" // Used as only type, so no circular.\nimport { Warning } from \"./warning-handler\"\n\nexport const InitEventWasCalledWhileDispatching = new Warning<[]>(\n    \"W01\",\n    \"Unable to initialize event under dispatching.\",\n)\n\nexport const FalsyWasAssignedToCancelBubble = new Warning<[]>(\n    \"W02\",\n    \"Assigning any falsy value to 'cancelBubble' property has no effect.\",\n)\n\nexport const TruthyWasAssignedToReturnValue = new Warning<[]>(\n    \"W03\",\n    \"Assigning any truthy value to 'returnValue' property has no effect.\",\n)\n\nexport const NonCancelableEventWasCanceled = new Warning<[]>(\n    \"W04\",\n    \"Unable to preventDefault on non-cancelable events.\",\n)\n\nexport const CanceledInPassiveListener = new Warning<[]>(\n    \"W05\",\n    \"Unable to preventDefault inside passive event listener invocation.\",\n)\n\nexport const EventListenerWasDuplicated = new Warning<\n    [type: \"bubble\" | \"capture\", callback: EventTarget.EventListener<any, any>]\n>(\n    \"W06\",\n    \"An event listener wasn't added because it has been added already: %o, %o\",\n)\n\nexport const OptionWasIgnored = new Warning<\n    [name: \"passive\" | \"once\" | \"signal\"]\n>(\n    \"W07\",\n    \"The %o option value was abandoned because the event listener wasn't added as duplicated.\",\n)\n\nexport const InvalidEventListener = new Warning<\n    [callback: EventTarget.EventListener<any, any> | {} | null | undefined]\n>(\n    \"W08\",\n    \"The 'callback' argument must be a function or an object that has 'handleEvent' method: %o\",\n)\n\nexport const InvalidAttributeHandler = new Warning<\n    [callback: EventTarget.EventListener<any, any> | {}]\n>(\"W09\", \"Event attribute handler must be a function: %o\")\n", "import { EventTarget } from \"./event-target\" // Used as only type, so no circular.\nimport { Global } from \"./global\"\nimport { assertType } from \"./misc\"\nimport {\n    CanceledInPassiveListener,\n    FalsyWasAssignedToCancelBubble,\n    InitEventWasCalledWhileDispatching,\n    NonCancelableEventWasCanceled,\n    TruthyWasAssignedToReturnValue,\n} from \"./warnings\"\n\n/*eslint-disable class-methods-use-this */\n\n/**\n * An implementation of `Event` interface, that wraps a given event object.\n * `EventTarget` shim can control the internal state of this `Event` objects.\n * @see https://dom.spec.whatwg.org/#event\n */\nexport class Event<TEventType extends string = string> {\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-none\n     */\n    static get NONE(): number {\n        return NONE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase\n     */\n    static get CAPTURING_PHASE(): number {\n        return CAPTURING_PHASE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-at_target\n     */\n    static get AT_TARGET(): number {\n        return AT_TARGET\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase\n     */\n    static get BUBBLING_PHASE(): number {\n        return BUBBLING_PHASE\n    }\n\n    /**\n     * Initialize this event instance.\n     * @param type The type of this event.\n     * @param eventInitDict Options to initialize.\n     * @see https://dom.spec.whatwg.org/#dom-event-event\n     */\n    constructor(type: TEventType, eventInitDict?: Event.EventInit) {\n        Object.defineProperty(this, \"isTrusted\", {\n            value: false,\n            enumerable: true,\n        })\n\n        const opts = eventInitDict ?? {}\n        internalDataMap.set(this, {\n            type: String(type),\n            bubbles: Boolean(opts.bubbles),\n            cancelable: Boolean(opts.cancelable),\n            composed: Boolean(opts.composed),\n            target: null,\n            currentTarget: null,\n            stopPropagationFlag: false,\n            stopImmediatePropagationFlag: false,\n            canceledFlag: false,\n            inPassiveListenerFlag: false,\n            dispatchFlag: false,\n            timeStamp: Date.now(),\n        })\n    }\n\n    /**\n     * The type of this event.\n     * @see https://dom.spec.whatwg.org/#dom-event-type\n     */\n    get type(): TEventType {\n        return $(this).type as TEventType\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * @see https://dom.spec.whatwg.org/#dom-event-target\n     */\n    get target(): EventTarget | null {\n        return $(this).target\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * @deprecated Use the `target` property instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-srcelement\n     */\n    get srcElement(): EventTarget | null {\n        return $(this).target\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * @see https://dom.spec.whatwg.org/#dom-event-currenttarget\n     */\n    get currentTarget(): EventTarget | null {\n        return $(this).currentTarget\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * This doesn't support node tree.\n     * @see https://dom.spec.whatwg.org/#dom-event-composedpath\n     */\n    composedPath(): EventTarget[] {\n        const currentTarget = $(this).currentTarget\n        if (currentTarget) {\n            return [currentTarget]\n        }\n        return []\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-none\n     */\n    get NONE(): number {\n        return NONE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase\n     */\n    get CAPTURING_PHASE(): number {\n        return CAPTURING_PHASE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-at_target\n     */\n    get AT_TARGET(): number {\n        return AT_TARGET\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase\n     */\n    get BUBBLING_PHASE(): number {\n        return BUBBLING_PHASE\n    }\n\n    /**\n     * The current event phase.\n     * @see https://dom.spec.whatwg.org/#dom-event-eventphase\n     */\n    get eventPhase(): number {\n        return $(this).dispatchFlag ? 2 : 0\n    }\n\n    /**\n     * Stop event bubbling.\n     * Because this shim doesn't support node tree, this merely changes the `cancelBubble` property value.\n     * @see https://dom.spec.whatwg.org/#dom-event-stoppropagation\n     */\n    stopPropagation(): void {\n        $(this).stopPropagationFlag = true\n    }\n\n    /**\n     * `true` if event bubbling was stopped.\n     * @deprecated\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble\n     */\n    get cancelBubble(): boolean {\n        return $(this).stopPropagationFlag\n    }\n\n    /**\n     * Stop event bubbling if `true` is set.\n     * @deprecated Use the `stopPropagation()` method instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble\n     */\n    set cancelBubble(value: boolean) {\n        if (value) {\n            $(this).stopPropagationFlag = true\n        } else {\n            FalsyWasAssignedToCancelBubble.warn()\n        }\n    }\n\n    /**\n     * Stop event bubbling and subsequent event listener callings.\n     * @see https://dom.spec.whatwg.org/#dom-event-stopimmediatepropagation\n     */\n    stopImmediatePropagation(): void {\n        const data = $(this)\n        data.stopPropagationFlag = data.stopImmediatePropagationFlag = true\n    }\n\n    /**\n     * `true` if this event will bubble.\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbles\n     */\n    get bubbles(): boolean {\n        return $(this).bubbles\n    }\n\n    /**\n     * `true` if this event can be canceled by the `preventDefault()` method.\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelable\n     */\n    get cancelable(): boolean {\n        return $(this).cancelable\n    }\n\n    /**\n     * `true` if the default behavior will act.\n     * @deprecated Use the `defaultPrevented` proeprty instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-returnvalue\n     */\n    get returnValue(): boolean {\n        return !$(this).canceledFlag\n    }\n\n    /**\n     * Cancel the default behavior if `false` is set.\n     * @deprecated Use the `preventDefault()` method instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-returnvalue\n     */\n    set returnValue(value: boolean) {\n        if (!value) {\n            setCancelFlag($(this))\n        } else {\n            TruthyWasAssignedToReturnValue.warn()\n        }\n    }\n\n    /**\n     * Cancel the default behavior.\n     * @see https://dom.spec.whatwg.org/#dom-event-preventdefault\n     */\n    preventDefault(): void {\n        setCancelFlag($(this))\n    }\n\n    /**\n     * `true` if the default behavior was canceled.\n     * @see https://dom.spec.whatwg.org/#dom-event-defaultprevented\n     */\n    get defaultPrevented(): boolean {\n        return $(this).canceledFlag\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     */\n    get composed(): boolean {\n        return $(this).composed\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-istrusted\n     */\n    //istanbul ignore next\n    get isTrusted(): boolean {\n        return false\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-timestamp\n     */\n    get timeStamp(): number {\n        return $(this).timeStamp\n    }\n\n    /**\n     * @deprecated Don't use this method. The constructor did initialization.\n     */\n    initEvent(type: string, bubbles = false, cancelable = false) {\n        const data = $(this)\n        if (data.dispatchFlag) {\n            InitEventWasCalledWhileDispatching.warn()\n            return\n        }\n\n        internalDataMap.set(this, {\n            ...data,\n            type: String(type),\n            bubbles: Boolean(bubbles),\n            cancelable: Boolean(cancelable),\n            target: null,\n            currentTarget: null,\n            stopPropagationFlag: false,\n            stopImmediatePropagationFlag: false,\n            canceledFlag: false,\n        })\n    }\n}\n\n/*eslint-enable class-methods-use-this */\n\nexport namespace Event {\n    /**\n     * The options of the `Event` constructor.\n     * @see https://dom.spec.whatwg.org/#dictdef-eventinit\n     */\n    export interface EventInit {\n        bubbles?: boolean\n        cancelable?: boolean\n        composed?: boolean\n    }\n}\n\nexport { $ as getEventInternalData }\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst NONE = 0\nconst CAPTURING_PHASE = 1\nconst AT_TARGET = 2\nconst BUBBLING_PHASE = 3\n\n/**\n * Private data.\n */\ninterface EventInternalData {\n    /**\n     * The value of `type` attribute.\n     */\n    readonly type: string\n    /**\n     * The value of `bubbles` attribute.\n     */\n    readonly bubbles: boolean\n    /**\n     * The value of `cancelable` attribute.\n     */\n    readonly cancelable: boolean\n    /**\n     * The value of `composed` attribute.\n     */\n    readonly composed: boolean\n    /**\n     * The value of `timeStamp` attribute.\n     */\n    readonly timeStamp: number\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-target\n     */\n    target: EventTarget | null\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-currenttarget\n     */\n    currentTarget: EventTarget | null\n    /**\n     * @see https://dom.spec.whatwg.org/#stop-propagation-flag\n     */\n    stopPropagationFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#stop-immediate-propagation-flag\n     */\n    stopImmediatePropagationFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#canceled-flag\n     */\n    canceledFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#in-passive-listener-flag\n     */\n    inPassiveListenerFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#dispatch-flag\n     */\n    dispatchFlag: boolean\n}\n\n/**\n * Private data for event wrappers.\n */\nconst internalDataMap = new WeakMap<any, EventInternalData>()\n\n/**\n * Get private data.\n * @param event The event object to get private data.\n * @param name The variable name to report.\n * @returns The private data of the event.\n */\nfunction $(event: unknown, name = \"this\"): EventInternalData {\n    const retv = internalDataMap.get(event)\n    assertType(\n        retv != null,\n        \"'%s' must be an object that Event constructor created, but got another one: %o\",\n        name,\n        event,\n    )\n    return retv\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data private data.\n */\nfunction setCancelFlag(data: EventInternalData) {\n    if (data.inPassiveListenerFlag) {\n        CanceledInPassiveListener.warn()\n        return\n    }\n    if (!data.cancelable) {\n        NonCancelableEventWasCanceled.warn()\n        return\n    }\n\n    data.canceledFlag = true\n}\n\n// Set enumerable\nObject.defineProperty(Event, \"NONE\", { enumerable: true })\nObject.defineProperty(Event, \"CAPTURING_PHASE\", { enumerable: true })\nObject.defineProperty(Event, \"AT_TARGET\", { enumerable: true })\nObject.defineProperty(Event, \"BUBBLING_PHASE\", { enumerable: true })\nconst keys = Object.getOwnPropertyNames(Event.prototype)\nfor (let i = 0; i < keys.length; ++i) {\n    if (keys[i] === \"constructor\") {\n        continue\n    }\n    Object.defineProperty(Event.prototype, keys[i], { enumerable: true })\n}\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, Global.Event.prototype)\n}\n", "import { Global } from \"./global\"\n\n/**\n * Create a new InvalidStateError instance.\n * @param message The error message.\n */\nexport function createInvalidStateError(message: string): Error {\n    if (Global.DOMException) {\n        return new Global.DOMException(message, \"InvalidStateError\")\n    }\n\n    if (DOMException == null) {\n        DOMException = class DOMException extends Error {\n            constructor(msg: string) {\n                super(msg)\n                if ((Error as any).captureStackTrace) {\n                    ;(Error as any).captureStackTrace(this, DOMException)\n                }\n            }\n            // eslint-disable-next-line class-methods-use-this\n            get code() {\n                return 11\n            }\n            // eslint-disable-next-line class-methods-use-this\n            get name() {\n                return \"InvalidStateError\"\n            }\n        }\n        Object.defineProperties(DOMException.prototype, {\n            code: { enumerable: true },\n            name: { enumerable: true },\n        })\n        defineErrorCodeProperties(DOMException)\n        defineErrorCodeProperties(DOMException.prototype)\n    }\n    return new DOMException(message)\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nlet DOMException: { new (message: string): Error } | undefined\n\nconst ErrorCodeMap = {\n    INDEX_SIZE_ERR: 1,\n    DOMSTRING_SIZE_ERR: 2,\n    HIERARCHY_REQUEST_ERR: 3,\n    WRONG_DOCUMENT_ERR: 4,\n    INVALID_CHARACTER_ERR: 5,\n    NO_DATA_ALLOWED_ERR: 6,\n    NO_MODIFICATION_ALLOWED_ERR: 7,\n    NOT_FOUND_ERR: 8,\n    NOT_SUPPORTED_ERR: 9,\n    INUSE_ATTRIBUTE_ERR: 10,\n    INVALID_STATE_ERR: 11,\n    SYNTAX_ERR: 12,\n    INVALID_MODIFICATION_ERR: 13,\n    NAMESPACE_ERR: 14,\n    INVALID_ACCESS_ERR: 15,\n    VALIDATION_ERR: 16,\n    TYPE_MISMATCH_ERR: 17,\n    SECURITY_ERR: 18,\n    NETWORK_ERR: 19,\n    ABORT_ERR: 20,\n    URL_MISMATCH_ERR: 21,\n    QUOTA_EXCEEDED_ERR: 22,\n    TIMEOUT_ERR: 23,\n    INVALID_NODE_TYPE_ERR: 24,\n    DATA_CLONE_ERR: 25,\n}\ntype ErrorCodeMap = typeof ErrorCodeMap\n\nfunction defineErrorCodeProperties(obj: any): void {\n    const keys = Object.keys(ErrorCodeMap) as (keyof ErrorCodeMap)[]\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        const value = ErrorCodeMap[key]\n        Object.defineProperty(obj, key, {\n            get() {\n                return value\n            },\n            configurable: true,\n            enumerable: true,\n        })\n    }\n}\n", "import { Event } from \"./event\"\nimport { Global } from \"./global\"\nimport { assertType } from \"./misc\"\n\n/**\n * An implementation of `Event` interface, that wraps a given event object.\n * This class controls the internal state of `Event`.\n * @see https://dom.spec.whatwg.org/#interface-event\n */\nexport class EventWrapper<TEventType extends string> extends Event<TEventType> {\n    /**\n     * Wrap a given event object to control states.\n     * @param event The event-like object to wrap.\n     */\n    static wrap<T extends EventLike>(event: T): EventWrapperOf<T> {\n        return new (getWrapperClassOf(event))(event)\n    }\n\n    protected constructor(event: Event<TEventType>) {\n        super(event.type, {\n            bubbles: event.bubbles,\n            cancelable: event.cancelable,\n            composed: event.composed,\n        })\n\n        if (event.cancelBubble) {\n            super.stopPropagation()\n        }\n        if (event.defaultPrevented) {\n            super.preventDefault()\n        }\n\n        internalDataMap.set(this, { original: event })\n\n        // Define accessors\n        const keys = Object.keys(event)\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i]\n            if (!(key in this)) {\n                Object.defineProperty(\n                    this,\n                    key,\n                    defineRedirectDescriptor(event, key),\n                )\n            }\n        }\n    }\n\n    stopPropagation(): void {\n        super.stopPropagation()\n\n        const { original } = $(this)\n        if (\"stopPropagation\" in original) {\n            original.stopPropagation!()\n        }\n    }\n\n    get cancelBubble(): boolean {\n        return super.cancelBubble\n    }\n    set cancelBubble(value: boolean) {\n        super.cancelBubble = value\n\n        const { original } = $(this)\n        if (\"cancelBubble\" in original) {\n            original.cancelBubble = value\n        }\n    }\n\n    stopImmediatePropagation(): void {\n        super.stopImmediatePropagation()\n\n        const { original } = $(this)\n        if (\"stopImmediatePropagation\" in original) {\n            original.stopImmediatePropagation!()\n        }\n    }\n\n    get returnValue(): boolean {\n        return super.returnValue\n    }\n    set returnValue(value: boolean) {\n        super.returnValue = value\n\n        const { original } = $(this)\n        if (\"returnValue\" in original) {\n            original.returnValue = value\n        }\n    }\n\n    preventDefault(): void {\n        super.preventDefault()\n\n        const { original } = $(this)\n        if (\"preventDefault\" in original) {\n            original.preventDefault!()\n        }\n    }\n\n    get timeStamp(): number {\n        const { original } = $(this)\n        if (\"timeStamp\" in original) {\n            return original.timeStamp!\n        }\n        return super.timeStamp\n    }\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\ntype EventLike = { readonly type: string } & Partial<Event>\ntype EventWrapperOf<T extends EventLike> = Event<T[\"type\"]> &\n    Omit<T, keyof Event>\n\ninterface EventWrapperInternalData {\n    readonly original: EventLike\n}\n\n/**\n * Private data for event wrappers.\n */\nconst internalDataMap = new WeakMap<any, EventWrapperInternalData>()\n\n/**\n * Get private data.\n * @param event The event object to get private data.\n * @returns The private data of the event.\n */\nfunction $(event: unknown): EventWrapperInternalData {\n    const retv = internalDataMap.get(event)\n    assertType(\n        retv != null,\n        \"'this' is expected an Event object, but got\",\n        event,\n    )\n    return retv\n}\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrapperClassCache = new WeakMap()\n\n// Make association for wrappers.\nwrapperClassCache.set(Object.prototype, EventWrapper)\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n    wrapperClassCache.set(Global.Event.prototype, EventWrapper)\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param originalEvent The event object to wrap.\n */\nfunction getWrapperClassOf<T extends EventLike>(\n    originalEvent: T,\n): { new (e: T): EventWrapperOf<T> } {\n    const prototype = Object.getPrototypeOf(originalEvent)\n    if (prototype == null) {\n        return EventWrapper as any\n    }\n\n    let wrapper: any = wrapperClassCache.get(prototype)\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapperClassOf(prototype), prototype)\n        wrapperClassCache.set(prototype, wrapper)\n    }\n\n    return wrapper\n}\n\n/**\n * Define new wrapper class.\n * @param BaseEventWrapper The base wrapper class.\n * @param originalPrototype The prototype of the original event.\n */\nfunction defineWrapper(BaseEventWrapper: any, originalPrototype: any): any {\n    class CustomEventWrapper extends BaseEventWrapper {}\n\n    const keys = Object.keys(originalPrototype)\n    for (let i = 0; i < keys.length; ++i) {\n        Object.defineProperty(\n            CustomEventWrapper.prototype,\n            keys[i],\n            defineRedirectDescriptor(originalPrototype, keys[i]),\n        )\n    }\n\n    return CustomEventWrapper\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n */\nfunction defineRedirectDescriptor(obj: any, key: string): PropertyDescriptor {\n    const d = Object.getOwnPropertyDescriptor(obj, key)!\n    return {\n        get() {\n            const original: any = $(this).original\n            const value = original[key]\n            if (typeof value === \"function\") {\n                return value.bind(original)\n            }\n            return value\n        },\n        set(value: any) {\n            const original: any = $(this).original\n            original[key] = value\n        },\n        configurable: d.configurable,\n        enumerable: d.enumerable,\n    }\n}\n", "import { reportError } from \"./error-handler\"\nimport { Event } from \"./event\" // Used as only type, so no circular.\nimport { EventTarget } from \"./event-target\" // Used as only type, so no circular.\n\n/**\n * The event listener concept.\n * @see https://dom.spec.whatwg.org/#concept-event-listener\n */\nexport interface Listener {\n    /**\n     * The callback function.\n     */\n    readonly callback: Listener.Callback<any, any>\n    /**\n     * The flags of this listener.\n     * This is writable to add the removed flag.\n     */\n    flags: ListenerFlags\n    /**\n     * The `AbortSignal` to remove this listener.\n     */\n    readonly signal: Listener.AbortSignal | undefined\n    /**\n     * The `abort` event listener for the `signal`.\n     * To remove it from the `signal`.\n     */\n    readonly signalListener: (() => void) | undefined\n}\n\nexport namespace Listener {\n    export type Callback<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > = CallbackFunction<TEventTarget, TEvent> | CallbackObject<TEvent>\n\n    export interface CallbackFunction<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > {\n        (this: TEventTarget, event: TEvent): void\n    }\n\n    export interface CallbackObject<TEvent extends Event> {\n        handleEvent(event: TEvent): void\n    }\n\n    export interface AbortSignal {\n        addEventListener(type: string, callback: Callback<any, Event>): void\n        removeEventListener(type: string, callback: Callback<any, Event>): void\n    }\n}\n\n/**\n * Create a new listener.\n * @param callback The callback function.\n * @param capture The capture flag.\n * @param passive The passive flag.\n * @param once The once flag.\n * @param signal The abort signal.\n * @param signalListener The abort event listener for the abort signal.\n */\nexport function createListener(\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n    passive: boolean,\n    once: boolean,\n    signal: Listener.AbortSignal | undefined,\n    signalListener: (() => void) | undefined,\n): Listener {\n    return {\n        callback,\n        flags:\n            (capture ? ListenerFlags.Capture : 0) |\n            (passive ? ListenerFlags.Passive : 0) |\n            (once ? ListenerFlags.Once : 0),\n        signal,\n        signalListener,\n    }\n}\n\n/**\n * Set the `removed` flag to the given listener.\n * @param listener The listener to check.\n */\nexport function setRemoved(listener: Listener): void {\n    listener.flags |= ListenerFlags.Removed\n}\n\n/**\n * Check if the given listener has the `capture` flag or not.\n * @param listener The listener to check.\n */\nexport function isCapture(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Capture) === ListenerFlags.Capture\n}\n\n/**\n * Check if the given listener has the `passive` flag or not.\n * @param listener The listener to check.\n */\nexport function isPassive(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Passive) === ListenerFlags.Passive\n}\n\n/**\n * Check if the given listener has the `once` flag or not.\n * @param listener The listener to check.\n */\nexport function isOnce(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Once) === ListenerFlags.Once\n}\n\n/**\n * Check if the given listener has the `removed` flag or not.\n * @param listener The listener to check.\n */\nexport function isRemoved(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Removed) === ListenerFlags.Removed\n}\n\n/**\n * Call an event listener.\n * @param listener The listener to call.\n * @param target The event target object for `thisArg`.\n * @param event The event object for the first argument.\n * @param attribute `true` if this callback is an event attribute handler.\n */\nexport function invokeCallback(\n    { callback }: Listener,\n    target: EventTarget<any, any>,\n    event: Event<any>,\n): void {\n    try {\n        if (typeof callback === \"function\") {\n            callback.call(target, event)\n        } else if (typeof callback.handleEvent === \"function\") {\n            callback.handleEvent(event)\n        }\n    } catch (thrownError) {\n        reportError(thrownError)\n    }\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * The flags of listeners.\n */\nconst enum ListenerFlags {\n    Capture = 0x01,\n    Passive = 0x02,\n    Once = 0x04,\n    Removed = 0x08,\n}\n", "import { createListener, isCapture, Listener, setRemoved } from \"./listener\"\n\n/**\n * Information of an listener list.\n */\nexport interface ListenerList {\n    /**\n     * The callback function of the event attribute handler.\n     */\n    attrCallback: Listener.CallbackFunction<any, any> | undefined\n    /**\n     * The listener of the event attribute handler.\n     */\n    attrListener: Listener | undefined\n    /**\n     * `true` if the `dispatchEvent` method is traversing the current `listeners` array.\n     */\n    cow: boolean\n    /**\n     * The listeners.\n     * This is writable for copy-on-write.\n     */\n    listeners: Listener[]\n}\n\n/**\n * Find the index of given listener.\n * This returns `-1` if not found.\n * @param list The listener list.\n * @param callback The callback function to find.\n * @param capture The capture flag to find.\n */\nexport function findIndexOfListener(\n    { listeners }: ListenerList,\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n): number {\n    for (let i = 0; i < listeners.length; ++i) {\n        if (\n            listeners[i].callback === callback &&\n            isCapture(listeners[i]) === capture\n        ) {\n            return i\n        }\n    }\n    return -1\n}\n\n/**\n * Add the given listener.\n * Does copy-on-write if needed.\n * @param list The listener list.\n * @param callback The callback function.\n * @param capture The capture flag.\n * @param passive The passive flag.\n * @param once The once flag.\n * @param signal The abort signal.\n */\nexport function addListener(\n    list: ListenerList,\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n    passive: boolean,\n    once: boolean,\n    signal: Listener.AbortSignal | undefined,\n): Listener {\n    let signalListener: (() => void) | undefined\n    if (signal) {\n        signalListener = removeListener.bind(null, list, callback, capture)\n        signal.addEventListener(\"abort\", signalListener)\n    }\n\n    const listener = createListener(\n        callback,\n        capture,\n        passive,\n        once,\n        signal,\n        signalListener,\n    )\n\n    if (list.cow) {\n        list.cow = false\n        list.listeners = [...list.listeners, listener]\n    } else {\n        list.listeners.push(listener)\n    }\n\n    return listener\n}\n\n/**\n * Remove a listener.\n * @param list The listener list.\n * @param callback The callback function to find.\n * @param capture The capture flag to find.\n * @returns `true` if it mutated the list directly.\n */\nexport function removeListener(\n    list: ListenerList,\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n): boolean {\n    const index = findIndexOfListener(list, callback, capture)\n    if (index !== -1) {\n        return removeListenerAt(list, index)\n    }\n    return false\n}\n\n/**\n * Remove a listener.\n * @param list The listener list.\n * @param index The index of the target listener.\n * @param disableCow Disable copy-on-write if true.\n * @returns `true` if it mutated the `listeners` array directly.\n */\nexport function removeListenerAt(\n    list: ListenerList,\n    index: number,\n    disableCow = false,\n): boolean {\n    const listener = list.listeners[index]\n\n    // Set the removed flag.\n    setRemoved(listener)\n\n    // Dispose the abort signal listener if exists.\n    if (listener.signal) {\n        listener.signal.removeEventListener(\"abort\", listener.signalListener!)\n    }\n\n    // Remove it from the array.\n    if (list.cow && !disableCow) {\n        list.cow = false\n        list.listeners = list.listeners.filter((_, i) => i !== index)\n        return false\n    }\n    list.listeners.splice(index, 1)\n    return true\n}\n", "import { ListenerList } from \"./listener-list\"\n\n/**\n * The map from event types to each listener list.\n */\nexport interface ListenerListMap {\n    [type: string]: ListenerList | undefined\n}\n\n/**\n * Create a new `ListenerListMap` object.\n */\nexport function createListenerListMap(): ListenerListMap {\n    return Object.create(null)\n}\n\n/**\n * Get the listener list of the given type.\n * If the listener list has not been initialized, initialize and return it.\n * @param listenerMap The listener list map.\n * @param type The event type to get.\n */\nexport function ensureListenerList(\n    listenerMap: Record<string, ListenerList | undefined>,\n    type: string,\n): ListenerList {\n    return (listenerMap[type] ??= {\n        attrCallback: undefined,\n        attrListener: undefined,\n        cow: false,\n        listeners: [],\n    })\n}\n", "import { createInvalidStateError } from \"./dom-exception\"\nimport { Event, getEventInternalData } from \"./event\"\nimport { EventWrapper } from \"./event-wrapper\"\nimport { Global } from \"./global\"\nimport {\n    invokeCallback,\n    isCapture,\n    isOnce,\n    isPassive,\n    isRemoved,\n    Listener,\n} from \"./listener\"\nimport {\n    addListener,\n    findIndexOfListener,\n    removeListener,\n    removeListenerAt,\n} from \"./listener-list\"\nimport {\n    createListenerListMap,\n    ensureListenerList,\n    ListenerListMap,\n} from \"./listener-list-map\"\nimport { assertType, format } from \"./misc\"\nimport {\n    EventListenerWasDuplicated,\n    InvalidEventListener,\n    OptionWasIgnored,\n} from \"./warnings\"\n\n/**\n * An implementation of the `EventTarget` interface.\n * @see https://dom.spec.whatwg.org/#eventtarget\n */\nexport class EventTarget<\n    TEventMap extends Record<string, Event> = Record<string, Event>,\n    TMode extends \"standard\" | \"strict\" = \"standard\"\n> {\n    /**\n     * Initialize this instance.\n     */\n    constructor() {\n        internalDataMap.set(this, createListenerListMap())\n    }\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    addEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options?: EventTarget.AddOptions,\n    ): void\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    addEventListener(\n        type: string,\n        callback?: EventTarget.FallbackEventListener<this, TMode>,\n        options?: EventTarget.AddOptions,\n    ): void\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    addEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback:\n            | EventTarget.EventListener<this, TEventMap[T]>\n            | null\n            | undefined,\n        capture: boolean,\n    ): void\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    addEventListener(\n        type: string,\n        callback: EventTarget.FallbackEventListener<this, TMode>,\n        capture: boolean,\n    ): void\n\n    // Implementation\n    addEventListener<T extends string & keyof TEventMap>(\n        type0: T,\n        callback0?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options0?: boolean | EventTarget.AddOptions,\n    ): void {\n        const listenerMap = $(this)\n        const {\n            callback,\n            capture,\n            once,\n            passive,\n            signal,\n            type,\n        } = normalizeAddOptions(type0, callback0, options0)\n        if (callback == null || signal?.aborted) {\n            return\n        }\n        const list = ensureListenerList(listenerMap, type)\n\n        // Find existing listener.\n        const i = findIndexOfListener(list, callback, capture)\n        if (i !== -1) {\n            warnDuplicate(list.listeners[i], passive, once, signal)\n            return\n        }\n\n        // Add the new listener.\n        addListener(list, callback, capture, passive, once, signal)\n    }\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    removeEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options?: EventTarget.Options,\n    ): void\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    removeEventListener(\n        type: string,\n        callback?: EventTarget.FallbackEventListener<this, TMode>,\n        options?: EventTarget.Options,\n    ): void\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    removeEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback:\n            | EventTarget.EventListener<this, TEventMap[T]>\n            | null\n            | undefined,\n        capture: boolean,\n    ): void\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    removeEventListener(\n        type: string,\n        callback: EventTarget.FallbackEventListener<this, TMode>,\n        capture: boolean,\n    ): void\n\n    // Implementation\n    removeEventListener<T extends string & keyof TEventMap>(\n        type0: T,\n        callback0?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options0?: boolean | EventTarget.Options,\n    ): void {\n        const listenerMap = $(this)\n        const { callback, capture, type } = normalizeOptions(\n            type0,\n            callback0,\n            options0,\n        )\n        const list = listenerMap[type]\n\n        if (callback != null && list) {\n            removeListener(list, callback, capture)\n        }\n    }\n\n    /**\n     * Dispatch an event.\n     * @param event The `Event` object to dispatch.\n     */\n    dispatchEvent<T extends string & keyof TEventMap>(\n        event: EventTarget.EventData<TEventMap, TMode, T>,\n    ): boolean\n\n    /**\n     * Dispatch an event.\n     * @param event The `Event` object to dispatch.\n     */\n    dispatchEvent(event: EventTarget.FallbackEvent<TMode>): boolean\n\n    // Implementation\n    dispatchEvent(\n        e:\n            | EventTarget.EventData<TEventMap, TMode, string>\n            | EventTarget.FallbackEvent<TMode>,\n    ): boolean {\n        const list = $(this)[String(e.type)]\n        if (list == null) {\n            return true\n        }\n\n        const event = e instanceof Event ? e : EventWrapper.wrap(e)\n        const eventData = getEventInternalData(event, \"event\")\n        if (eventData.dispatchFlag) {\n            throw createInvalidStateError(\"This event has been in dispatching.\")\n        }\n\n        eventData.dispatchFlag = true\n        eventData.target = eventData.currentTarget = this\n\n        if (!eventData.stopPropagationFlag) {\n            const { cow, listeners } = list\n\n            // Set copy-on-write flag.\n            list.cow = true\n\n            // Call listeners.\n            for (let i = 0; i < listeners.length; ++i) {\n                const listener = listeners[i]\n\n                // Skip if removed.\n                if (isRemoved(listener)) {\n                    continue\n                }\n\n                // Remove this listener if has the `once` flag.\n                if (isOnce(listener) && removeListenerAt(list, i, !cow)) {\n                    // Because this listener was removed, the next index is the\n                    // same as the current value.\n                    i -= 1\n                }\n\n                // Call this listener with the `passive` flag.\n                eventData.inPassiveListenerFlag = isPassive(listener)\n                invokeCallback(listener, this, event)\n                eventData.inPassiveListenerFlag = false\n\n                // Stop if the `event.stopImmediatePropagation()` method was called.\n                if (eventData.stopImmediatePropagationFlag) {\n                    break\n                }\n            }\n\n            // Restore copy-on-write flag.\n            if (!cow) {\n                list.cow = false\n            }\n        }\n\n        eventData.target = null\n        eventData.currentTarget = null\n        eventData.stopImmediatePropagationFlag = false\n        eventData.stopPropagationFlag = false\n        eventData.dispatchFlag = false\n\n        return !eventData.canceledFlag\n    }\n}\n\nexport namespace EventTarget {\n    /**\n     * The event listener.\n     */\n    export type EventListener<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > = CallbackFunction<TEventTarget, TEvent> | CallbackObject<TEvent>\n\n    /**\n     * The event listener function.\n     */\n    export interface CallbackFunction<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > {\n        (this: TEventTarget, event: TEvent): void\n    }\n\n    /**\n     * The event listener object.\n     * @see https://dom.spec.whatwg.org/#callbackdef-eventlistener\n     */\n    export interface CallbackObject<TEvent extends Event> {\n        handleEvent(event: TEvent): void\n    }\n\n    /**\n     * The common options for both `addEventListener` and `removeEventListener` methods.\n     * @see https://dom.spec.whatwg.org/#dictdef-eventlisteneroptions\n     */\n    export interface Options {\n        capture?: boolean\n    }\n\n    /**\n     * The options for the `addEventListener` methods.\n     * @see https://dom.spec.whatwg.org/#dictdef-addeventlisteneroptions\n     */\n    export interface AddOptions extends Options {\n        passive?: boolean\n        once?: boolean\n        signal?: AbortSignal | null | undefined\n    }\n\n    /**\n     * The abort signal.\n     * @see https://dom.spec.whatwg.org/#abortsignal\n     */\n    export interface AbortSignal extends EventTarget<{ abort: Event }> {\n        readonly aborted: boolean\n        onabort: CallbackFunction<this, Event> | null\n    }\n\n    /**\n     * The event data to dispatch in strict mode.\n     */\n    export type EventData<\n        TEventMap extends Record<string, Event>,\n        TMode extends \"standard\" | \"strict\",\n        TEventType extends string\n    > = TMode extends \"strict\"\n        ? IsValidEventMap<TEventMap> extends true\n            ? ExplicitType<TEventType> &\n                  Omit<TEventMap[TEventType], keyof Event> &\n                  Partial<Omit<Event, \"type\">>\n            : never\n        : never\n\n    /**\n     * Define explicit `type` property if `T` is a string literal.\n     * Otherwise, never.\n     */\n    export type ExplicitType<T extends string> = string extends T\n        ? never\n        : { readonly type: T }\n\n    /**\n     * The event listener type in standard mode.\n     * Otherwise, never.\n     */\n    export type FallbackEventListener<\n        TEventTarget extends EventTarget<any, any>,\n        TMode extends \"standard\" | \"strict\"\n    > = TMode extends \"standard\"\n        ? EventListener<TEventTarget, Event> | null | undefined\n        : never\n\n    /**\n     * The event type in standard mode.\n     * Otherwise, never.\n     */\n    export type FallbackEvent<\n        TMode extends \"standard\" | \"strict\"\n    > = TMode extends \"standard\" ? Event : never\n\n    /**\n     * Check if given event map is valid.\n     * It's valid if the keys of the event map are narrower than `string`.\n     */\n    export type IsValidEventMap<T> = string extends keyof T ? false : true\n}\n\nexport { $ as getEventTargetInternalData }\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Internal data for EventTarget\n */\ntype EventTargetInternalData = ListenerListMap\n\n/**\n * Internal data.\n */\nconst internalDataMap = new WeakMap<any, EventTargetInternalData>()\n\n/**\n * Get private data.\n * @param target The event target object to get private data.\n * @param name The variable name to report.\n * @returns The private data of the event.\n */\nfunction $(target: any, name = \"this\"): EventTargetInternalData {\n    const retv = internalDataMap.get(target)\n    assertType(\n        retv != null,\n        \"'%s' must be an object that EventTarget constructor created, but got another one: %o\",\n        name,\n        target,\n    )\n    return retv\n}\n\n/**\n * Normalize options.\n * @param options The options to normalize.\n */\nfunction normalizeAddOptions(\n    type: string,\n    callback: EventTarget.EventListener<any, any> | null | undefined,\n    options: boolean | EventTarget.AddOptions | undefined,\n): {\n    type: string\n    callback: EventTarget.EventListener<any, any> | undefined\n    capture: boolean\n    passive: boolean\n    once: boolean\n    signal: EventTarget.AbortSignal | undefined\n} {\n    assertCallback(callback)\n\n    if (typeof options === \"object\" && options !== null) {\n        return {\n            type: String(type),\n            callback: callback ?? undefined,\n            capture: Boolean(options.capture),\n            passive: Boolean(options.passive),\n            once: Boolean(options.once),\n            signal: options.signal ?? undefined,\n        }\n    }\n\n    return {\n        type: String(type),\n        callback: callback ?? undefined,\n        capture: Boolean(options),\n        passive: false,\n        once: false,\n        signal: undefined,\n    }\n}\n\n/**\n * Normalize options.\n * @param options The options to normalize.\n */\nfunction normalizeOptions(\n    type: string,\n    callback: EventTarget.EventListener<any, any> | null | undefined,\n    options: boolean | EventTarget.Options | undefined,\n): {\n    type: string\n    callback: EventTarget.EventListener<any, any> | undefined\n    capture: boolean\n} {\n    assertCallback(callback)\n\n    if (typeof options === \"object\" && options !== null) {\n        return {\n            type: String(type),\n            callback: callback ?? undefined,\n            capture: Boolean(options.capture),\n        }\n    }\n\n    return {\n        type: String(type),\n        callback: callback ?? undefined,\n        capture: Boolean(options),\n    }\n}\n\n/**\n * Assert the type of 'callback' argument.\n * @param callback The callback to check.\n */\nfunction assertCallback(callback: any): void {\n    if (\n        typeof callback === \"function\" ||\n        (typeof callback === \"object\" &&\n            callback !== null &&\n            typeof callback.handleEvent === \"function\")\n    ) {\n        return\n    }\n    if (callback == null || typeof callback === \"object\") {\n        InvalidEventListener.warn(callback)\n        return\n    }\n\n    throw new TypeError(format(InvalidEventListener.message, [callback]))\n}\n\n/**\n * Print warning for duplicated.\n * @param listener The current listener that is duplicated.\n * @param passive The passive flag of the new duplicated listener.\n * @param once The once flag of the new duplicated listener.\n * @param signal The signal object of the new duplicated listener.\n */\nfunction warnDuplicate(\n    listener: Listener,\n    passive: boolean,\n    once: boolean,\n    signal: EventTarget.AbortSignal | undefined,\n): void {\n    EventListenerWasDuplicated.warn(\n        isCapture(listener) ? \"capture\" : \"bubble\",\n        listener.callback,\n    )\n\n    if (isPassive(listener) !== passive) {\n        OptionWasIgnored.warn(\"passive\")\n    }\n    if (isOnce(listener) !== once) {\n        OptionWasIgnored.warn(\"once\")\n    }\n    if (listener.signal !== signal) {\n        OptionWasIgnored.warn(\"signal\")\n    }\n}\n\n// Set enumerable\nconst keys = Object.getOwnPropertyNames(EventTarget.prototype)\nfor (let i = 0; i < keys.length; ++i) {\n    if (keys[i] === \"constructor\") {\n        continue\n    }\n    Object.defineProperty(EventTarget.prototype, keys[i], { enumerable: true })\n}\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof Global !== \"undefined\" &&\n    typeof Global.EventTarget !== \"undefined\"\n) {\n    Object.setPrototypeOf(EventTarget.prototype, Global.EventTarget.prototype)\n}\n", "import { Event } from \"./event\"\nimport { EventTarget, getEventTargetInternalData } from \"./event-target\"\nimport { addListener, ListenerList, removeListener } from \"./listener-list\"\nimport { ensureListenerList } from \"./listener-list-map\"\nimport { InvalidAttributeHandler } from \"./warnings\"\n\n/**\n * Get the current value of a given event attribute.\n * @param target The `EventTarget` object to get.\n * @param type The event type.\n */\nexport function getEventAttributeValue<\n    TEventTarget extends EventTarget<any, any>,\n    TEvent extends Event\n>(\n    target: TEventTarget,\n    type: string,\n): EventTarget.CallbackFunction<TEventTarget, TEvent> | null {\n    const listMap = getEventTargetInternalData(target, \"target\")\n    return listMap[type]?.attrCallback ?? null\n}\n\n/**\n * Set an event listener to a given event attribute.\n * @param target The `EventTarget` object to set.\n * @param type The event type.\n * @param callback The event listener.\n */\nexport function setEventAttributeValue(\n    target: EventTarget<any, any>,\n    type: string,\n    callback: EventTarget.CallbackFunction<any, any> | null,\n): void {\n    if (callback != null && typeof callback !== \"function\") {\n        InvalidAttributeHandler.warn(callback)\n    }\n\n    if (\n        typeof callback === \"function\" ||\n        (typeof callback === \"object\" && callback !== null)\n    ) {\n        upsertEventAttributeListener(target, type, callback)\n    } else {\n        removeEventAttributeListener(target, type)\n    }\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Update or insert the given event attribute handler.\n * @param target The `EventTarget` object to set.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction upsertEventAttributeListener<\n    TEventTarget extends EventTarget<any, any>\n>(\n    target: TEventTarget,\n    type: string,\n    callback: EventTarget.CallbackFunction<TEventTarget, any>,\n): void {\n    const list = ensureListenerList(\n        getEventTargetInternalData(target, \"target\"),\n        String(type),\n    )\n    list.attrCallback = callback\n\n    if (list.attrListener == null) {\n        list.attrListener = addListener(\n            list,\n            defineEventAttributeCallback(list),\n            false,\n            false,\n            false,\n            undefined,\n        )\n    }\n}\n\n/**\n * Remove the given event attribute handler.\n * @param target The `EventTarget` object to remove.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction removeEventAttributeListener(\n    target: EventTarget<any, any>,\n    type: string,\n): void {\n    const listMap = getEventTargetInternalData(target, \"target\")\n    const list = listMap[String(type)]\n    if (list && list.attrListener) {\n        removeListener(list, list.attrListener.callback, false)\n        list.attrCallback = list.attrListener = undefined\n    }\n}\n\n/**\n * Define the callback function for the given listener list object.\n * It calls `attrCallback` property if the property value is a function.\n * @param list The `ListenerList` object.\n */\nfunction defineEventAttributeCallback(\n    list: ListenerList,\n): EventTarget.CallbackFunction<any, any> {\n    return function (event) {\n        const callback = list.attrCallback\n        if (typeof callback === \"function\") {\n            callback.call(this, event)\n        }\n    }\n}\n", "import { Event } from \"./event\"\nimport {\n    getEventAttributeValue,\n    setEventAttributeValue,\n} from \"./event-attribute-handler\"\nimport { EventTarget } from \"./event-target\"\n\n/**\n * Define an `EventTarget` class that has event attibutes.\n * @param types The types to define event attributes.\n * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.\n */\nexport function defineCustomEventTarget<\n    TEventMap extends Record<string, Event>,\n    TMode extends \"standard\" | \"strict\" = \"standard\"\n>(\n    ...types: (string & keyof TEventMap)[]\n): defineCustomEventTarget.CustomEventTargetConstructor<TEventMap, TMode> {\n    class CustomEventTarget extends EventTarget {}\n    for (let i = 0; i < types.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, types[i])\n    }\n\n    return CustomEventTarget as any\n}\n\nexport namespace defineCustomEventTarget {\n    /**\n     * The interface of CustomEventTarget constructor.\n     */\n    export type CustomEventTargetConstructor<\n        TEventMap extends Record<string, Event>,\n        TMode extends \"standard\" | \"strict\"\n    > = {\n        /**\n         * Create a new instance.\n         */\n        new (): CustomEventTarget<TEventMap, TMode>\n        /**\n         * prototype object.\n         */\n        prototype: CustomEventTarget<TEventMap, TMode>\n    }\n\n    /**\n     * The interface of CustomEventTarget.\n     */\n    export type CustomEventTarget<\n        TEventMap extends Record<string, Event>,\n        TMode extends \"standard\" | \"strict\"\n    > = EventTarget<TEventMap, TMode> &\n        defineEventAttribute.EventAttributes<any, TEventMap>\n}\n\n/**\n * Define an event attribute.\n * @param target The `EventTarget` object to define an event attribute.\n * @param type The event type to define.\n * @param _eventClass Unused, but to infer `Event` class type.\n * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.\n */\nexport function defineEventAttribute<\n    TEventTarget extends EventTarget,\n    TEventType extends string,\n    TEventConstrucor extends typeof Event\n>(\n    target: TEventTarget,\n    type: TEventType,\n    _eventClass?: TEventConstrucor,\n): asserts target is TEventTarget &\n    defineEventAttribute.EventAttributes<\n        TEventTarget,\n        Record<TEventType, InstanceType<TEventConstrucor>>\n    > {\n    Object.defineProperty(target, `on${type}`, {\n        get() {\n            return getEventAttributeValue(this, type)\n        },\n        set(value) {\n            setEventAttributeValue(this, type, value)\n        },\n        configurable: true,\n        enumerable: true,\n    })\n}\n\nexport namespace defineEventAttribute {\n    /**\n     * Definition of event attributes.\n     */\n    export type EventAttributes<\n        TEventTarget extends EventTarget<any, any>,\n        TEventMap extends Record<string, Event>\n    > = {\n        [P in string &\n            keyof TEventMap as `on${P}`]: EventTarget.CallbackFunction<\n            TEventTarget,\n            TEventMap[P]\n        > | null\n    }\n}\n", "import { EventTarget, Event } from 'event-target-shim';\nimport xhr, { type XhrUrlConfig, type XhrHeaders, type XhrResponse } from 'xhr';\n\nconst DEFAULT_CHUNK_SIZE = 30720;\nconst DEFAULT_MAX_CHUNK_SIZE = 512000; // in kB\nconst DEFAULT_MIN_CHUNK_SIZE = 256; // in kB\n\n// Predicate function that returns true if a given `chunkSize` is valid, otherwise false.\n// For `chunkSize` validity, we constrain by a min/max chunk size and conform to GCS:\n// \"The chunk size should be a multiple of 256 KiB (256 x 1024 bytes), unless it's the last \n// chunk that completes the upload.\" (See: https://cloud.google.com/storage/docs/performing-resumable-uploads)\nexport const isValidChunkSize = (\n  chunkSize: any,\n  {\n    minChunkSize = DEFAULT_MIN_CHUNK_SIZE,\n    maxChunkSize = DEFAULT_MAX_CHUNK_SIZE,\n  } = {}\n): chunkSize is number | null | undefined => {\n  return (\n    chunkSize == null ||\n    (typeof chunkSize === 'number' &&\n      chunkSize >= 256 &&\n      chunkSize % 256 === 0 &&\n      chunkSize >= minChunkSize &&\n      chunkSize <= maxChunkSize)\n  );\n};\n\n// Projection function that returns an error associated with invalid `chunkSize` values.\nexport const getChunkSizeError = (\n  chunkSize: any,\n  {\n    minChunkSize = DEFAULT_MIN_CHUNK_SIZE,\n    maxChunkSize = DEFAULT_MAX_CHUNK_SIZE,\n  } = {}\n) => {\n  return new TypeError(\n    `chunkSize ${chunkSize} must be a positive number in multiples of 256, between ${minChunkSize} and ${maxChunkSize}`\n  );\n};\n\nexport type ChunkedStreamIterableOptions = {\n  defaultChunkSize?: number;\n  minChunkSize?: number;\n  maxChunkSize?: number;\n};\n\n// An Iterable that accepts a readableStream of binary data (Blob | Uint8Array) and provides\n// an asyncIterator which yields Blob values of the current chunkSize until done. Note that\n// chunkSize may change between iterations.\nexport class ChunkedStreamIterable implements AsyncIterable<Blob> {\n  protected _chunkSize: number | undefined;\n  protected defaultChunkSize: number;\n  public readonly minChunkSize: number;\n  public readonly maxChunkSize: number;\n\n  constructor(\n    protected readableStream: ReadableStream<Uint8Array | Blob>,\n    options: ChunkedStreamIterableOptions = {}\n  ) {\n    if (!isValidChunkSize(options.defaultChunkSize, options)) {\n      throw getChunkSizeError(options.defaultChunkSize, options);\n    }\n    this.defaultChunkSize = options.defaultChunkSize ?? DEFAULT_CHUNK_SIZE;\n    this.minChunkSize = options.minChunkSize ?? DEFAULT_MIN_CHUNK_SIZE;\n    this.maxChunkSize = options.maxChunkSize ?? DEFAULT_MAX_CHUNK_SIZE;\n  }\n\n  get chunkSize() {\n    return this._chunkSize ?? this.defaultChunkSize;\n  }\n\n  set chunkSize(value) {\n    if (!isValidChunkSize(value, this)) {\n      throw getChunkSizeError(value, this);\n    }\n    this._chunkSize = value;\n  }\n\n  get chunkByteSize() {\n    return this.chunkSize * 1024;\n  }\n\n  async *[Symbol.asyncIterator](): AsyncIterator<Blob> {\n    let chunk;\n    const reader = this.readableStream.getReader();\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          // Last chunk, if any bits remain\n          if (chunk) {\n            const outgoingChunk = chunk;\n            chunk = undefined;\n            yield outgoingChunk;\n          }\n          break;\n        }\n\n        const normalizedBlobChunk =\n          value instanceof Uint8Array\n            ? new Blob([value], { type: 'application/octet-stream' })\n            : value;\n\n        chunk = chunk\n          ? new Blob([chunk, normalizedBlobChunk])\n          : normalizedBlobChunk;\n\n        // NOTE: Since we don't know how big the next chunk needs to be, we should\n        // just have a single blob that we \"peel away bytes from\" for each chunk\n        // as we iterate.\n        while (chunk) {\n          if (chunk.size === this.chunkByteSize) {\n            const outgoingChunk = chunk;\n            chunk = undefined;\n            yield outgoingChunk;\n            break;\n          } else if (chunk.size < this.chunkByteSize) {\n            break;\n          } else {\n            const outgoingChunk = chunk.slice(0, this.chunkByteSize);\n            chunk = chunk.slice(this.chunkByteSize);\n            yield outgoingChunk;\n          }\n        }\n      }\n    } finally {\n      // Last chunk, if any bits remain\n      if (chunk) {\n        const outgoingChunk = chunk;\n        chunk = undefined;\n        yield outgoingChunk;\n      }\n      reader.releaseLock();\n      return;\n    }\n  }\n}\n\nconst SUCCESSFUL_CHUNK_UPLOAD_CODES = [200, 201, 202, 204, 308];\nconst TEMPORARY_ERROR_CODES = [408, 502, 503, 504]; // These error codes imply a chunk may be retried\n\ntype UploadPredOptions = {\n  retryCodes?: typeof TEMPORARY_ERROR_CODES;\n  attempts: number;\n  attemptCount: number;\n};\nconst isSuccessfulChunkUpload = (\n  res: XhrResponse | undefined,\n  _options?: any\n): res is XhrResponse =>\n  !!res && SUCCESSFUL_CHUNK_UPLOAD_CODES.includes(res.statusCode);\n\nconst isRetriableChunkUpload = (\n  res: XhrResponse | undefined,\n  { retryCodes = TEMPORARY_ERROR_CODES }: UploadPredOptions\n) => !res || retryCodes.includes(res.statusCode);\n\nconst isFailedChunkUpload = (\n  res: XhrResponse | undefined,\n  options: UploadPredOptions\n): res is XhrResponse => {\n  return (\n    options.attemptCount >= options.attempts ||\n    !(isSuccessfulChunkUpload(res) || isRetriableChunkUpload(res, options))\n  );\n};\n\ntype EventName =\n  | 'attempt'\n  | 'attemptFailure'\n  | 'chunkSuccess'\n  | 'error'\n  | 'offline'\n  | 'online'\n  | 'progress'\n  | 'success';\n\n// NOTE: This and the EventTarget definition below could be more precise\n// by e.g. typing the detail of the CustomEvent per EventName.\ntype UpchunkEvent = CustomEvent & Event<EventName>;\n\ntype AllowedMethods = 'PUT' | 'POST' | 'PATCH';\n\nexport interface UpChunkOptions {\n  endpoint: string | ((file?: File) => Promise<string>);\n  file: File;\n  method?: AllowedMethods;\n  headers?: XhrHeaders;\n  maxFileSize?: number;\n  chunkSize?: number;\n  attempts?: number;\n  delayBeforeAttempt?: number;\n  retryCodes?: number[];\n  dynamicChunkSize?: boolean;\n  maxChunkSize?: number;\n  minChunkSize?: number;\n}\n\nexport class UpChunk {\n  public endpoint: string | ((file?: File) => Promise<string>);\n  public file: File;\n  public headers: XhrHeaders;\n  public method: AllowedMethods;\n  public attempts: number;\n  public delayBeforeAttempt: number;\n  public retryCodes: number[];\n  public dynamicChunkSize: boolean;\n  protected chunkedStreamIterable: ChunkedStreamIterable;\n  protected chunkedStreamIterator;\n\n  protected pendingChunk?: Blob;\n  private chunkCount: number;\n  private maxFileBytes: number;\n  private endpointValue: string;\n  private totalChunks: number;\n  private attemptCount: number;\n  private offline: boolean;\n  private _paused: boolean;\n  private success: boolean;\n  private currentXhr?: XMLHttpRequest;\n  private lastChunkStart: Date;\n  private nextChunkRangeStart: number;\n\n  private eventTarget: EventTarget<Record<EventName, UpchunkEvent>>;\n\n  constructor(options: UpChunkOptions) {\n    this.endpoint = options.endpoint;\n    this.file = options.file;\n\n    this.headers = options.headers || ({} as XhrHeaders);\n    this.method = options.method || 'PUT';\n    this.attempts = options.attempts || 5;\n    this.delayBeforeAttempt = options.delayBeforeAttempt || 1;\n    this.retryCodes = options.retryCodes || TEMPORARY_ERROR_CODES;\n    this.dynamicChunkSize = options.dynamicChunkSize || false;\n\n    this.maxFileBytes = (options.maxFileSize || 0) * 1024;\n    this.chunkCount = 0;\n    this.attemptCount = 0;\n    this.offline = false;\n    this._paused = false;\n    this.success = false;\n    this.nextChunkRangeStart = 0;\n\n    // Types appear to be getting confused in env setup, using the overloaded NodeJS Blob definition, which uses NodeJS.ReadableStream instead\n    // of the DOM type definitions. For definitions, See consumers.d.ts vs. lib.dom.d.ts. (CJP)\n    this.chunkedStreamIterable = new ChunkedStreamIterable(\n      this.file.stream() as unknown as ReadableStream<Uint8Array>,\n      { ...options, defaultChunkSize: options.chunkSize }\n    );\n    this.chunkedStreamIterator =\n      this.chunkedStreamIterable[Symbol.asyncIterator]();\n\n    this.totalChunks = Math.ceil(this.file.size / this.chunkByteSize);\n\n    this.eventTarget = new EventTarget();\n\n    this.validateOptions();\n    this.getEndpoint().then(() => this.sendChunks());\n\n    // restart sync when back online\n    // trigger events when offline/back online\n    if (typeof window !== 'undefined') {\n      window.addEventListener('online', () => {\n        if (!this.offline) {\n          return;\n        }\n\n        this.offline = false;\n        this.dispatch('online');\n        this.sendChunks();\n      });\n\n      window.addEventListener('offline', () => {\n        this.offline = true;\n        this.dispatch('offline');\n      });\n    }\n  }\n\n  protected get maxChunkSize() {\n    return this.chunkedStreamIterable?.chunkSize ?? DEFAULT_MAX_CHUNK_SIZE;\n  }\n\n  protected get minChunkSize() {\n    return this.chunkedStreamIterable?.chunkSize ?? DEFAULT_MIN_CHUNK_SIZE;\n  }\n\n  public get chunkSize() {\n    return this.chunkedStreamIterable?.chunkSize ?? DEFAULT_CHUNK_SIZE;\n  }\n\n  public set chunkSize(value) {\n    this.chunkedStreamIterable.chunkSize = value;\n  }\n\n  public get chunkByteSize() {\n    return this.chunkedStreamIterable.chunkByteSize;\n  }\n\n  public get totalChunkSize() {\n    return Math.ceil(this.file.size / this.chunkByteSize);\n  }\n\n  /**\n   * Subscribe to an event\n   */\n  public on(eventName: EventName, fn: (event: CustomEvent) => void) {\n    this.eventTarget.addEventListener(eventName, fn as EventListener);\n  }\n\n  /**\n   * Subscribe to an event once\n   */\n  public once(eventName: EventName, fn: (event: CustomEvent) => void) {\n    this.eventTarget.addEventListener(eventName, fn as EventListener, { once: true });\n  }\n\n  /**\n   * Unsubscribe to an event\n   */\n  public off(eventName: EventName, fn: (event: CustomEvent) => void) {\n    this.eventTarget.removeEventListener(eventName, fn as EventListener);\n  }\n\n  public get paused() {\n    return this._paused;\n  }\n\n  public abort() {\n    this.pause();\n    this.currentXhr?.abort();\n  }\n\n  public pause() {\n    this._paused = true;\n  }\n\n  public resume() {\n    if (this._paused) {\n      this._paused = false;\n\n      this.sendChunks();\n    }\n  }\n\n  /**\n   * Dispatch an event\n   */\n  private dispatch(eventName: EventName, detail?: any) {\n    const event: UpchunkEvent = new CustomEvent(eventName, {\n      detail,\n    }) as UpchunkEvent;\n\n    this.eventTarget.dispatchEvent(event);\n  }\n\n  /**\n   * Validate options and throw errors if expectations are violated.\n   */\n  private validateOptions() {\n    if (\n      !this.endpoint ||\n      (typeof this.endpoint !== 'function' && typeof this.endpoint !== 'string')\n    ) {\n      throw new TypeError(\n        'endpoint must be defined as a string or a function that returns a promise'\n      );\n    }\n    if (!(this.file instanceof File)) {\n      throw new TypeError('file must be a File object');\n    }\n    if (this.headers && typeof this.headers !== 'object') {\n      throw new TypeError('headers must be null or an object');\n    }\n    if (\n      !isValidChunkSize(this.chunkSize, {\n        maxChunkSize: this.maxChunkSize,\n        minChunkSize: this.minChunkSize,\n      })\n    ) {\n      throw getChunkSizeError(this.chunkSize, {\n        maxChunkSize: this.maxChunkSize,\n        minChunkSize: this.minChunkSize,\n      });\n    }\n    if (\n      this.maxChunkSize &&\n      (typeof this.maxChunkSize !== 'number' ||\n        this.maxChunkSize < 256 ||\n        this.maxChunkSize % 256 !== 0 ||\n        this.maxChunkSize < this.chunkSize ||\n        this.maxChunkSize < this.minChunkSize)\n    ) {\n      throw new TypeError(\n        `maxChunkSize must be a positive number in multiples of 256, and larger than or equal to both ${this.minChunkSize} and ${this.chunkSize}`\n      );\n    }\n    if (\n      this.minChunkSize &&\n      (typeof this.minChunkSize !== 'number' ||\n        this.minChunkSize < 256 ||\n        this.minChunkSize % 256 !== 0 ||\n        this.minChunkSize > this.chunkSize ||\n        this.minChunkSize > this.maxChunkSize)\n    ) {\n      throw new TypeError(\n        `minChunkSize must be a positive number in multiples of 256, and smaller than ${this.chunkSize} and ${this.maxChunkSize}`\n      );\n    }\n    if (this.maxFileBytes > 0 && this.maxFileBytes < this.file.size) {\n      throw new Error(\n        `file size exceeds maximum (${this.file.size} > ${this.maxFileBytes})`\n      );\n    }\n    if (\n      this.attempts &&\n      (typeof this.attempts !== 'number' || this.attempts <= 0)\n    ) {\n      throw new TypeError('retries must be a positive number');\n    }\n    if (\n      this.delayBeforeAttempt &&\n      (typeof this.delayBeforeAttempt !== 'number' ||\n        this.delayBeforeAttempt < 0)\n    ) {\n      throw new TypeError('delayBeforeAttempt must be a positive number');\n    }\n  }\n\n  /**\n   * Endpoint can either be a URL or a function that returns a promise that resolves to a string.\n   */\n  private getEndpoint() {\n    if (typeof this.endpoint === 'string') {\n      this.endpointValue = this.endpoint;\n      return Promise.resolve(this.endpoint);\n    }\n\n    return this.endpoint(this.file).then((value) => {\n      this.endpointValue = value;\n      return this.endpointValue;\n    });\n  }\n\n  private xhrPromise(options: XhrUrlConfig): Promise<XhrResponse> {\n    const beforeSend = (xhrObject: XMLHttpRequest) => {\n      xhrObject.upload.onprogress = (event: ProgressEvent) => {\n        const remainingChunks = this.totalChunks - this.chunkCount;\n        // const remainingBytes = this.file.size-(this.nextChunkRangeStart+event.loaded);\n        const percentagePerChunk =\n          (this.file.size - this.nextChunkRangeStart) /\n          this.file.size /\n          remainingChunks;\n        const successfulPercentage = this.nextChunkRangeStart / this.file.size;\n        const currentChunkProgress =\n          event.loaded / (event.total ?? this.chunkByteSize);\n        const chunkPercentage = currentChunkProgress * percentagePerChunk;\n        this.dispatch(\n          'progress',\n          Math.min((successfulPercentage + chunkPercentage) * 100, 100)\n        );\n      };\n    };\n\n    return new Promise((resolve, reject) => {\n      this.currentXhr = xhr({ ...options, beforeSend }, (err, resp) => {\n        this.currentXhr = undefined;\n        if (err) {\n          return reject(err);\n        }\n\n        return resolve(resp);\n      });\n    });\n  }\n\n  /**\n   * Send chunk of the file with appropriate headers\n   */\n  protected async sendChunk(chunk: Blob) {\n    const rangeStart = this.nextChunkRangeStart;\n    const rangeEnd = rangeStart + chunk.size - 1;\n    const headers = {\n      ...this.headers,\n      'Content-Type': this.file.type,\n      'Content-Range': `bytes ${rangeStart}-${rangeEnd}/${this.file.size}`,\n    };\n\n    this.dispatch('attempt', {\n      chunkNumber: this.chunkCount,\n      totalChunks: this.totalChunks,\n      chunkSize: this.chunkSize,\n    });\n\n    return this.xhrPromise({\n      headers,\n      url: this.endpointValue,\n      method: this.method,\n      body: chunk,\n    });\n  }\n\n  protected async sendChunkWithRetries(chunk: Blob): Promise<boolean> {\n    // What to do if a chunk was successfully uploaded\n    const successfulChunkUploadCb = async (res: XhrResponse, _chunk?: Blob) => {\n      // Side effects\n      const lastChunkEnd = new Date();\n      const lastChunkInterval =\n        (lastChunkEnd.getTime() - this.lastChunkStart.getTime()) / 1000;\n\n      this.dispatch('chunkSuccess', {\n        chunk: this.chunkCount,\n        chunkSize: this.chunkSize,\n        attempts: this.attemptCount,\n        timeInterval: lastChunkInterval,\n        response: res,\n      });\n\n      this.attemptCount = 0;\n      this.chunkCount = (this.chunkCount ?? 0) + 1;\n      this.nextChunkRangeStart = this.nextChunkRangeStart + this.chunkByteSize;\n      if (this.dynamicChunkSize) {\n        let unevenChunkSize = this.chunkSize;\n        if (lastChunkInterval < 10) {\n          unevenChunkSize = Math.min(this.chunkSize * 2, this.maxChunkSize);\n        } else if (lastChunkInterval > 30) {\n          unevenChunkSize = Math.max(this.chunkSize / 2, this.minChunkSize);\n        }\n        // ensure it's a multiple of 256k\n        this.chunkSize = Math.ceil(unevenChunkSize / 256) * 256;\n\n        // Re-estimate the total number of chunks, by adding the completed\n        // chunks to the remaining chunks\n        const remainingChunks =\n          (this.file.size - this.nextChunkRangeStart) / this.chunkByteSize;\n        this.totalChunks = Math.ceil(this.chunkCount + remainingChunks);\n      }\n\n      return true;\n    };\n\n    // What to do if a chunk upload failed, potentially after retries\n    const failedChunkUploadCb = async (res: XhrResponse, _chunk?: Blob) => {\n      // Side effects\n      this.dispatch('error', {\n        message: `Server responded with ${\n          (res as XhrResponse).statusCode\n        }. Stopping upload.`,\n        chunk: this.chunkCount,\n        attempts: this.attemptCount,\n      });\n\n      return false;\n    };\n\n    // What to do if a chunk upload failed but is retriable and hasn't exceeded retry\n    // count\n    const retriableChunkUploadCb = async (\n      _res: XhrResponse | undefined,\n      _chunk?: Blob\n    ) => {\n      // Side effects\n      this.dispatch('attemptFailure', {\n        message: `An error occured uploading chunk ${this.chunkCount}. ${\n          this.attempts - this.attemptCount\n        } retries left.`,\n        chunkNumber: this.chunkCount,\n        attemptsLeft: this.attempts - this.attemptCount,\n      });\n\n      return new Promise<boolean>((resolve) => {\n        setTimeout(async () => {\n          // Handle mid-flight _paused/offline cases here by storing the\n          // \"still retriable but yet to be uploaded chunk\" in state.\n          // See also: `sendChunks()`\n          if (this._paused || this.offline) {\n            this.pendingChunk = chunk;\n            resolve(false);\n            return;\n          }\n          const chunkUploadSuccess = await this.sendChunkWithRetries(chunk);\n          resolve(chunkUploadSuccess);\n        }, this.delayBeforeAttempt * 1000);\n      });\n    };\n\n    let res: XhrResponse | undefined;\n    try {\n      this.attemptCount = this.attemptCount + 1;\n      this.lastChunkStart = new Date();\n      res = await this.sendChunk(chunk);\n    } catch (_err) {\n      // this type of error can happen after network disconnection on CORS setup\n    }\n    const options = {\n      retryCodes: this.retryCodes,\n      attemptCount: this.attemptCount,\n      attempts: this.attempts,\n    };\n    if (isSuccessfulChunkUpload(res, options)) {\n      return successfulChunkUploadCb(res, chunk);\n    }\n    if (isFailedChunkUpload(res, options)) {\n      return failedChunkUploadCb(res, chunk);\n    }\n    // Retriable case\n    return retriableChunkUploadCb(res, chunk);\n  }\n\n  /**\n   * Manage the whole upload by calling getChunk & sendChunk\n   * handle errors & retries and dispatch events\n   */\n  private async sendChunks() {\n    // A \"pending chunk\" is a chunk that was unsuccessful but still retriable when\n    // uploading was _paused or the env is offline. Since this may be the last\n    if (this.pendingChunk && !(this._paused || this.offline)) {\n      const chunk = this.pendingChunk;\n      this.pendingChunk = undefined;\n      const chunkUploadSuccess = await this.sendChunkWithRetries(chunk);\n      if (this.success && chunkUploadSuccess) {\n        this.dispatch('success');\n      }\n    }\n\n    while (!(this.success || this._paused || this.offline)) {\n      const { value: chunk, done } = await this.chunkedStreamIterator.next();\n      // NOTE: When `done`, `chunk` is undefined, so default `chunkUploadSuccess` \n      // to be `true` on this condition, otherwise `false`.\n      let chunkUploadSuccess = !chunk && done;\n      if (chunk) {\n        chunkUploadSuccess = await this.sendChunkWithRetries(chunk);\n      }\n      // NOTE: Need to disambiguate \"last chunk to upload\" (done) vs. \"successfully\"\n      // uploaded last chunk to upload\" (depends on status of sendChunkWithRetries),\n      // specifically for \"pending chunk\" cases for the last chunk.\n      this.success = !!done;\n      if (this.success && chunkUploadSuccess) {\n        this.dispatch('success');\n      }\n      if (!chunkUploadSuccess) {\n        return;\n      }\n    }\n  }\n}\n\nexport const createUpload = (options: UpChunkOptions) => new UpChunk(options);\n", "class EventTarget {\n  addEventListener() {}\n  removeEventListener() {}\n  dispatchEvent(_event) {\n    return true;\n  }\n}\n\n// @github/template-parts requires DocumentFragment to be available on globalThis for SSR\nif (typeof DocumentFragment === 'undefined') {\n  class DocumentFragment extends EventTarget {}\n  // @ts-ignore\n  globalThis.DocumentFragment = DocumentFragment;\n}\n\nclass HTMLElement extends EventTarget {}\nclass HTMLVideoElement extends EventTarget {}\n\nconst customElements = {\n  get(_name) {\n    return undefined;\n  },\n  define(_name, _constructor, _options) {},\n  upgrade(_root) {},\n  whenDefined(_name) {\n    return Promise.resolve(HTMLElement);\n  },\n};\n\nclass CustomEvent {\n  #detail;\n  get detail() {\n    return this.#detail;\n  }\n  constructor(typeArg, eventInitDict = {}) {\n    // super(typeArg, eventInitDict);\n    this.#detail = eventInitDict?.detail;\n  }\n  initCustomEvent() {}\n}\n\nfunction createElement(_tagName, _options) {\n  return new HTMLElement();\n}\n\nconst globalThisShim = {\n  document: {\n    createElement,\n  },\n  DocumentFragment,\n  customElements,\n  CustomEvent,\n  EventTarget,\n  HTMLElement,\n  HTMLVideoElement,\n};\n\nconst isServer = typeof window === 'undefined' || typeof globalThis.customElements === 'undefined';\nconst GlobalThis = isServer ? globalThisShim : globalThis;\nconst Document = isServer ? globalThisShim.document : globalThis.document;\n\nexport { GlobalThis as globalThis, Document as document };\n", "import { globalThis, document } from 'shared-polyfills';\n\nconst template = document.createElement('template');\n\n/** @todo: Currently removing all styles. Follow up on overlay styling (CJP) */\ntemplate.innerHTML = `\n<style>\n  :host {\n    position: relative;\n  }\n\n  #overlay {\n    display: none;\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    right: 0;\n    left: 0;\n    height: 100%;\n    width: 100%;\n  }\n\n  :host([active][overlay]) > #overlay {\n    background: var(--overlay-background-color, rgba(226, 253, 255, 0.95));\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n  }\n</style>\n\n<slot></slot>\n<div id=\"overlay\">\n  <h1 id=\"overlay-label\"></h1>\n</div>\n`;\n\nconst Attributes = {\n  MUX_UPLOADER: 'mux-uploader',\n  OVERLAY_TEXT: 'overlay-text',\n};\n\nclass MuxUploaderDropElement extends globalThis.HTMLElement {\n  overlayText: HTMLElement;\n\n  constructor() {\n    super();\n    const shadowRoot = this.attachShadow({ mode: 'open' });\n    shadowRoot.appendChild(template.content.cloneNode(true));\n\n    this.overlayText = shadowRoot.getElementById('overlay-label') as HTMLElement;\n  }\n\n  connectedCallback() {\n    this.setupDragEvents();\n  }\n\n  attributeChangedCallback(attributeName: string, oldValue: string | null, newValue: string | null) {\n    if (attributeName === Attributes.OVERLAY_TEXT && oldValue !== newValue) {\n      this.overlayText.innerHTML = newValue ?? '';\n    } else if (attributeName === 'active') {\n      if (this.getAttribute('overlay') && newValue != null) {\n        this._currentDragTarget = this;\n      }\n    }\n  }\n\n  static get observedAttributes() {\n    return [Attributes.OVERLAY_TEXT, Attributes.MUX_UPLOADER, 'active'];\n  }\n\n  get muxUploader() {\n    const uploaderId = this.getAttribute(Attributes.MUX_UPLOADER);\n    return uploaderId ? document.getElementById(uploaderId) : null;\n  }\n\n  protected _currentDragTarget?: Node;\n\n  setupDragEvents() {\n    this.addEventListener('dragenter', (evt) => {\n      this._currentDragTarget = evt.target as Node;\n      evt.preventDefault();\n      evt.stopPropagation();\n      this.setAttribute('active', '');\n    });\n\n    this.addEventListener('dragleave', (evt) => {\n      if (this._currentDragTarget === evt.target) {\n        this._currentDragTarget = undefined;\n        this.removeAttribute('active');\n      }\n    });\n\n    this.addEventListener('dragover', (evt) => {\n      evt.preventDefault();\n      evt.stopPropagation();\n    });\n\n    this.addEventListener('drop', (evt) => {\n      evt.preventDefault();\n      evt.stopPropagation();\n      const { dataTransfer } = evt;\n      //@ts-ignore\n      const { files } = dataTransfer;\n      const file = files[0];\n\n      const uploaderController = this.muxUploader ?? this;\n\n      uploaderController.dispatchEvent(\n        new CustomEvent('file-ready', {\n          composed: true,\n          bubbles: true,\n          detail: file,\n        })\n      );\n\n      this.removeAttribute('active');\n    });\n  }\n}\n\nif (!globalThis.customElements.get('mux-uploader-drop')) {\n  globalThis.customElements.define('mux-uploader-drop', MuxUploaderDropElement);\n  //@ts-ignore\n  globalThis.MuxUploaderDropElement = MuxUploaderDropElement;\n}\n\nexport default MuxUploaderDropElement;\n", "import { globalThis, document } from 'shared-polyfills';\n// Still need to import this to ensure component registration occurs when using the main module.\n// Consider refactoring module structure to avoid this. (CJP)\nimport './mux-uploader-drop';\nimport * as UpChunk from '@mux/upchunk';\n\nconst styles = `\n:host {\n  font-family: var(--uploader-font-family, Arial);\n  font-size: var(--uploader-font-size, 16px);\n  background-color: var(--uploader-background-color, inherit);\n}\n\n.sr-only {\n  position:absolute;\n  left:-10000px;\n  top:auto;\n  width:1px;\n  height:1px;\n  overflow:hidden;\n  }\n\np {\n  color: black;\n}\n\ninput[type=\"file\"] {\n  display: none;\n}\n\nbutton {\n  cursor: pointer;\n  line-height: 16px;\n  background: var(--button-background-color, #fff);\n  border: var(--button-border, 1px solid #000000);\n  color: #000000;\n  padding: var(--button-padding, 16px 24px);\n  border-radius: var(--button-border-radius, 4px);\n  -webkit-transition: all 0.2s ease;\n  transition: all 0.2s ease;\n  font-family: inherit;\n  font-size: inherit;\n  position: relative;\n}\n\nbutton:hover {\n  color: var(--button-hover-text, #fff);\n  background: var(--button-hover-background, #404040);\n}\n\nbutton:active {\n  color: var(--button-active-text, #fff);\n  background: var(--button-active-background, #000000);\n}\n\n.bar-type {\n  background: #e6e6e6;\n  border-radius: 100px;\n  position: relative;\n  height: 4px;\n  width: 100%;\n}\n\n.radial-type, .bar-type, .upload-status, .retry-button, .text-container {\n  display: none;\n}\n\n::slotted(p) {\n  display: none;\n}\n\n.upload-instruction {\n  display: none;\n}\n\n.retry-button {\n  color: #e22c3e;\n  text-decoration-line: underline;\n  cursor: pointer;\n  position: relative;\n}\n\n.text-container {\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  padding-bottom: 16px;\n}\n\n:host([type=\"radial\"][upload-in-progress]) .radial-type {\n  display: block;\n}\n\n:host([type=\"bar\"][upload-in-progress]) .bar-type {\n  display: block;\n}\n\n:host([upload-in-progress][status]) .upload-status {\n  display: block;\n}\n\n:host([upload-in-progress]) ::slotted(p) {\n  display: block;\n}\n\n:host([type=\"bar\"][upload-error]) .progress-bar {\n  background: #e22c3e;\n}\n\n:host([type=\"bar\"][upload-error]) .status-message {\n  color: #e22c3e;\n}\n\n:host([type=\"radial\"][upload-error]) .status-message {\n  color: #e22c3e;\n}\n\n:host([upload-error][status]) .upload-status {\n  display: none;\n}\n\n:host([upload-error]) .retry-button {\n  display: inline-block;\n}\n\n:host([upload-error]) .text-container {\n  display: flex;\n}\n\n:host([upload-error]) ::slotted(p) {\n  display: none;\n}\n\n.upload-status {\n  font-size: inherit;\n  margin-bottom: 16px;\n}\n\n.progress-bar {\n  box-shadow: 0 10px 40px -10px #fff;\n  border-radius: 100px;\n  background: var(--progress-bar-fill-color, #000000);\n  height: 4px;\n  width: 0%;\n}\n\n:host([upload-in-progress]) button {\n  display: none;\n}\n\n:host([upload-in-progress]) ::slotted(button) {\n  display: none;\n}\n\n:host([upload-in-progress]) .upload-instruction {\n  display: none;\n}\n\ncircle {\n  stroke: var(--progress-radial-fill-color, black);\n  stroke-width: 6;  /* Thickness of the circle */\n  fill: transparent; /* Make inside of the circle see-through */\n\n  /* Animation */ \n  transition: 0.35s;\n  transform: rotate(-90deg);\n  transform-origin: 50% 50%;\n  -webkit-transform-origin: 50% 50%;\n  -moz-transform-origin: 50% 50%;\n}\n`;\n\nconst template = document.createElement('template');\n\ntemplate.innerHTML = `\n<style>\n  ${styles}\n</style>\n\n<div class=\"sr-only\" id=\"sr-only\" aria-live=\"polite\"></div>\n\n<div class=text-container>\n  <span class=\"status-message\" id=\"status-message\" role=\"status\" aria-live=\"polite\"></span>\n  <span class=\"retry-button\" id=\"retry-button\" role=\"button\" tabindex=\"0\">Try again</span>\n</div>\n\n<input id=\"hidden-file-input\" type=\"file\" />\n<slot name=\"upload-button\"><button type=\"button\">Upload video</button></slot>\n<p class=\"upload-status\" id=\"upload-status\"></p>\n\n<div class=\"bar-type\">\n  <div role=\"progressbar\" aria-valuemin=\"0\" aria-valuemax=\"100\" class=\"progress-bar\" id=\"progress-bar\" tabindex=\"0\"></div>\n</div>\n<div class=\"radial-type\">\n  <svg\n    width=\"120\"\n    height=\"120\">\n    <!-- To prevent overflow of the SVG wrapper, radius must be  (svgWidth / 2) - (circleStrokeWidth * 2)\n      or use overflow: visible on the svg.-->\n    <circle\n      r=\"52\"\n      cx=\"60\"\n      cy=\"60\"\n    />\n  <svg>\n</div>\n`;\n\n// Note: Use \"bar\" for now since the CSS for radial is WIP. (TD).\nconst TYPES = {\n  BAR: 'bar',\n  RADIAL: 'radial',\n};\n\nconst defaultFormatProgress = (percent: number) => `${Math.floor(percent)}%`;\n\nconst getRadius = (el: MuxUploaderElement) => Number(el.svgCircle?.getAttribute('r'));\n\nconst getCircumference = (el: MuxUploaderElement) => getRadius(el) * 2 * Math.PI;\n\nconst ariaDescription = 'Media upload progress bar';\n\nconst ButtonPressedKeys = ['Enter', ' '];\n\ntype Endpoint = UpChunk.UpChunk['endpoint'] | undefined | null;\ntype DynamicChunkSize = UpChunk.UpChunk['dynamicChunkSize'] | undefined;\n\ntype ErrorDetail = {\n  message: string;\n  chunkNumber?: number;\n  attempts?: number;\n};\n\n// NOTE: Progress event is already determined on HTMLElement but have inconsistent types. Should consider renaming events (CJP)\nexport interface MuxUploaderElementEventMap extends Omit<HTMLElementEventMap, 'progress'> {\n  uploadstart: CustomEvent<{ file: File; chunkSize: number }>;\n  chunkattempt: CustomEvent<{\n    chunkNumber: number;\n    chunkSize: number;\n  }>;\n  chunksuccess: CustomEvent<{\n    chunk: number;\n    chunkSize: number;\n    attempts: number;\n    timeInterval: number;\n    // Note: This should be more explicitly typed in Upchunk. (TD).\n    response: any;\n  }>;\n  uploaderror: CustomEvent<ErrorDetail>;\n  progress: CustomEvent<number>;\n  success: CustomEvent<undefined | null>;\n}\n\ninterface MuxUploaderElement extends HTMLElement {\n  addEventListener<K extends keyof MuxUploaderElementEventMap>(\n    type: K,\n    listener: (this: HTMLMediaElement, ev: MuxUploaderElementEventMap[K]) => any,\n    options?: boolean | AddEventListenerOptions\n  ): void;\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions\n  ): void;\n  removeEventListener<K extends keyof MuxUploaderElementEventMap>(\n    type: K,\n    listener: (this: HTMLMediaElement, ev: MuxUploaderElementEventMap[K]) => any,\n    options?: boolean | EventListenerOptions\n  ): void;\n  removeEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions\n  ): void;\n}\n\nclass MuxUploaderElement extends globalThis.HTMLElement implements MuxUploaderElement {\n  protected _formatProgress: ((percent: number) => string) | null | undefined;\n  protected _filePickerButton: HTMLElement | null | undefined;\n  protected _endpoint: Endpoint;\n  svgCircle: SVGCircleElement | null | undefined;\n  progressBar: HTMLElement | null | undefined;\n  uploadPercentage: HTMLElement | null | undefined;\n  statusMessage: HTMLElement | null | undefined;\n  retryButton: HTMLElement | null | undefined;\n  srOnlyText: HTMLElement | null | undefined;\n\n  constructor() {\n    super();\n\n    // NOTE: Binding this so that we have a reference to remove the event listener\n    // but can still reference `this` in the method. (CJP)\n    this.handleFilePickerButtonClick = this.handleFilePickerButtonClick.bind(this);\n\n    const shadow = this.attachShadow({ mode: 'open' });\n    const uploaderHtml = template.content.cloneNode(true);\n    shadow.appendChild(uploaderHtml);\n\n    // Since we have a \"default slotted\" element, we still need to initialize the slottable elements\n    // (Note the difference in selectors and related code in 'slotchange' handler, below)\n    this.filePickerButton = this.shadowRoot?.querySelector('slot[name=upload-button] > *');\n    this.svgCircle = this.shadowRoot?.querySelector('circle');\n    this.progressBar = this.shadowRoot?.getElementById('progress-bar');\n    this.uploadPercentage = this.shadowRoot?.getElementById('upload-status');\n    this.statusMessage = this.shadowRoot?.getElementById('status-message');\n    this.retryButton = this.shadowRoot?.getElementById('retry-button');\n    this.srOnlyText = this.shadowRoot?.getElementById('sr-only');\n\n    this.progressBar?.setAttribute('aria-description', ariaDescription);\n\n    // These should only ever be setup once on instantiation/construction.\n    this.hiddenFileInput?.addEventListener('change', () => {\n      const file = this.hiddenFileInput?.files?.[0];\n\n      if (file) {\n        this.dispatchEvent(\n          new CustomEvent('file-ready', {\n            composed: true,\n            bubbles: true,\n            detail: file,\n          })\n        );\n      }\n    });\n    this.shadowRoot?.querySelector('slot[name=upload-button]')?.addEventListener('slotchange', () => {\n      this.filePickerButton = (\n        this.shadowRoot?.querySelector('slot[name=upload-button]') as HTMLSlotElement\n      )?.assignedNodes()[0] as HTMLButtonElement;\n    });\n  }\n\n  connectedCallback() {\n    this.setDefaultType();\n    this.setupRetry();\n    //@ts-ignore\n    this.addEventListener('file-ready', this.handleUpload);\n  }\n\n  disconnectedCallback() {\n    //@ts-ignore\n    this.removeEventListener('file-ready', this.handleUpload, false);\n  }\n\n  protected get filePickerButton() {\n    return this._filePickerButton;\n  }\n\n  protected set filePickerButton(value: HTMLElement | null | undefined) {\n    if (value === this._filePickerButton) return;\n    if (this._filePickerButton) {\n      this._filePickerButton.removeEventListener('click', this.handleFilePickerButtonClick);\n    }\n    this._filePickerButton = value;\n    if (this._filePickerButton) {\n      this._filePickerButton.addEventListener('click', this.handleFilePickerButtonClick);\n    }\n  }\n\n  protected get hiddenFileInput() {\n    return this.shadowRoot?.querySelector('#hidden-file-input') as HTMLInputElement;\n  }\n\n  handleFilePickerButtonClick() {\n    // TO-DO: Allow user to reattempt uploading the same file after an error.\n    // Note: Apparently Chrome and Firefox do not allow changing an indexed property on FileList...(TD).\n    // Source: https://stackoverflow.com/a/46689013\n    this.hiddenFileInput.click();\n  }\n\n  get endpoint(): Endpoint {\n    return this.getAttribute('endpoint') ?? this._endpoint;\n  }\n\n  set endpoint(value: Endpoint) {\n    if (value === this.endpoint) return;\n    if (typeof value === 'string') {\n      this.setAttribute('endpoint', value);\n    } else if (value == undefined) {\n      this.removeAttribute('endpoint');\n    }\n    this._endpoint = value;\n  }\n\n  get dynamicChunkSize(): DynamicChunkSize {\n    return this.hasAttribute('dynamic-chunk-size');\n  }\n\n  set dynamicChunkSize(value: DynamicChunkSize) {\n    if (value === this.hasAttribute('dynamic-chunk-size')) return;\n    if (value) {\n      this.setAttribute('dynamic-chunk-size', '');\n    } else {\n      this.removeAttribute('dynamic-chunk-size');\n    }\n  }\n\n  get formatProgress(): (percent: number) => string {\n    return this._formatProgress ?? defaultFormatProgress;\n  }\n\n  set formatProgress(value: ((percent: number) => string) | null | undefined) {\n    this._formatProgress = value;\n  }\n\n  setDefaultType() {\n    const currentType = this.getAttribute('type');\n\n    if (!currentType) {\n      this.setAttribute('type', TYPES.BAR);\n    }\n\n    if (currentType === TYPES.RADIAL) {\n      if (this.svgCircle) {\n        // strokeDasharray is the size of dashes used to draw the circle with the size of gaps in between.\n        // If the dash number is the same as the gap number, no gap is visible: a full circle.\n        // strokeDashoffset defines where along our circle the dashes (in our case, a dash as long as the\n        // circumference of our circle) begins. The larger the offset, the farther into the circle you're\n        // starting the \"dash\". In the beginning, offset is the same as the circumference. Meaning, the visible\n        // dash starts at the end so we don't see the full circle. Instead we see a gap the size of the circle.\n        // When the percentage is 100%, offset is 0 meaning the dash starts at the beginning so we can see the circle. (TD).\n        this.svgCircle.style.strokeDasharray = `${getCircumference(this)} ${getCircumference(this)}`;\n        this.svgCircle.style.strokeDashoffset = `${getCircumference(this)}`;\n      }\n    }\n  }\n\n  setupRetry() {\n    this.retryButton?.addEventListener('click', () => {\n      this.resetState();\n    });\n\n    // NOTE: There are definitely some \"false positive\" cases with multi-key pressing,\n    // but this should be good enough for most use cases.\n    const keyUpHandler = (e: KeyboardEvent) => {\n      const { key } = e;\n      if (!ButtonPressedKeys.includes(key)) {\n        this.removeEventListener('keyup', keyUpHandler);\n        return;\n      }\n\n      this.resetState();\n    };\n\n    this.addEventListener('keydown', (e) => {\n      const { metaKey, altKey, key } = e;\n      if (metaKey || altKey || !ButtonPressedKeys.includes(key)) {\n        this.removeEventListener('keyup', keyUpHandler);\n        return;\n      }\n      this.addEventListener('keyup', keyUpHandler);\n    });\n  }\n\n  resetState() {\n    this.removeAttribute('upload-error');\n    this.removeAttribute('upload-in-progress');\n    // Reset file to ensure change/input events will fire, even if selecting the same file (CJP).\n    this.hiddenFileInput.value = '';\n    if (this.statusMessage) this.statusMessage.innerHTML = '';\n    if (this.uploadPercentage) this.uploadPercentage.innerHTML = '';\n  }\n\n  setProgress(percent: number) {\n    if (this.uploadPercentage) this.uploadPercentage.innerHTML = this.formatProgress(percent);\n    this.progressBar?.setAttribute('aria-valuenow', `${Math.floor(percent)}`);\n\n    switch (this.getAttribute('type')) {\n      case TYPES.BAR: {\n        if (this.progressBar) this.progressBar.style.width = `${percent}%`;\n        break;\n      }\n      case TYPES.RADIAL: {\n        if (this.svgCircle) {\n          // The closer the upload percentage gets to 100%, the closer offset gets to 0.\n          // The closer offset gets to 0, the more we can see the circumference of our circle. (TD).\n          const offset = getCircumference(this) - (percent / 100) * getCircumference(this);\n\n          this.svgCircle.style.strokeDashoffset = offset.toString();\n        }\n      }\n    }\n  }\n\n  handleUpload(evt: CustomEvent) {\n    const endpoint = this.endpoint;\n    const dynamicChunkSize = this.dynamicChunkSize;\n\n    if (!endpoint) {\n      const invalidUrlMessage = 'No url or endpoint specified -- cannot handleUpload';\n      if (this.statusMessage) {\n        this.statusMessage.innerHTML = invalidUrlMessage;\n      }\n      this.setAttribute('upload-error', '');\n      console.error(invalidUrlMessage);\n      this.dispatchEvent(new CustomEvent('uploaderror', { detail: { message: invalidUrlMessage } }));\n      // Bail early if no endpoint.\n      return;\n    } else {\n      this.removeAttribute('upload-error');\n      if (this.statusMessage) {\n        this.statusMessage.innerHTML = '';\n      }\n    }\n\n    this.setAttribute('upload-in-progress', '');\n    this.progressBar?.focus();\n\n    const upload = UpChunk.createUpload({\n      endpoint,\n      dynamicChunkSize,\n      file: evt.detail,\n    });\n\n    this.dispatchEvent(new CustomEvent('uploadstart', { detail: { file: upload.file, chunkSize: upload.chunkSize } }));\n\n    upload.on('attempt', (event) => {\n      this.dispatchEvent(new CustomEvent('chunkattempt', event));\n    });\n\n    upload.on('chunkSuccess', (event) => {\n      this.dispatchEvent(new CustomEvent('chunksuccess', event));\n    });\n\n    upload.on('error', (event) => {\n      const errorMessage = 'An error has occurred';\n\n      this.setAttribute('upload-error', '');\n\n      if (this.statusMessage) {\n        this.statusMessage.innerHTML = errorMessage;\n      }\n\n      console.error(event.detail.message);\n      this.dispatchEvent(new CustomEvent('uploaderror', event));\n    });\n\n    upload.on('progress', (event) => {\n      this.setProgress(event.detail);\n      this.dispatchEvent(new CustomEvent('progress', event));\n    });\n\n    upload.on('success', (event) => {\n      const successMessage = 'Upload complete!';\n\n      if (this.statusMessage) {\n        this.statusMessage.innerHTML = successMessage;\n      }\n\n      // TO-DO: It seems like statusMessage cannot be updated within two different events. (TD).\n      // Timing? Need to look into this...\n      if (this.srOnlyText) {\n        this.srOnlyText.innerHTML = successMessage;\n      }\n\n      console.info(successMessage);\n      this.dispatchEvent(new CustomEvent('success', event));\n    });\n  }\n}\n\ntype MuxUploaderElementType = typeof MuxUploaderElement;\ndeclare global {\n  // eslint-disable-next-line\n  var MuxUploaderElement: MuxUploaderElementType;\n}\n\n/** @TODO Refactor once using `globalThis` polyfills */\nif (!globalThis.customElements.get('mux-uploader')) {\n  globalThis.customElements.define('mux-uploader', MuxUploaderElement);\n  /** @TODO consider externalizing this (breaks standard modularity) */\n  globalThis.MuxUploaderElement = MuxUploaderElement;\n}\n\nexport default MuxUploaderElement;\n", "import React from 'react';\nimport type { CSSProperties } from 'react';\nimport '@mux/mux-uploader';\nimport type MuxUploaderDropElement from '@mux/mux-uploader';\nimport { toNativeProps } from './common/utils';\nimport { useRef } from 'react';\nimport { useCombinedRefs } from './useCombinedRefs';\n\nexport type MuxUploaderDropRefAttributes = MuxUploaderDropElement;\n\nexport type MuxUploaderDropProps = {\n  overlay?: boolean;\n  overlayText?: string;\n  style?: CSSProperties & {\n    ['--overlay-background-color']?: CSSProperties['backgroundColor'];\n  };\n  children?: React.ReactNode;\n};\n\nconst MuxUploaderDropInternal = React.forwardRef<MuxUploaderDropRefAttributes, MuxUploaderDropProps>(\n  ({ children, ...props }, ref) => {\n    return React.createElement('mux-uploader-drop', toNativeProps({ ...props, ref }), children);\n  }\n);\n\nconst MuxUploaderDrop = React.forwardRef<MuxUploaderDropRefAttributes, MuxUploaderDropProps>((props, ref) => {\n  const innerUploaderDropRef = useRef<MuxUploaderDropElement>(null);\n  const uploaderDropRef = useCombinedRefs(innerUploaderDropRef, ref);\n\n  return <MuxUploaderDropInternal ref={uploaderDropRef as typeof innerUploaderDropRef} {...props} />;\n});\n\nexport default MuxUploaderDrop;\n", "// NOTE: As a forward-looking implementation, we may want to assume\n// prop names -> attribute names is always a simple name.toLowerCase()\n// and provide a mechanism for passing in per-component overrides for\n// e.g. kebab cases, as that's the way React/Preact handles these. (CJP)\nconst ReactPropToAttrNameMap = {\n  className: 'class',\n  classname: 'class',\n  htmlFor: 'for',\n  crossOrigin: 'crossorigin',\n  viewBox: 'viewBox',\n  playsInline: 'playsinline',\n  autoPlay: 'autoplay',\n};\n\ntype KeyTypes = string | number | symbol;\n\nexport const isNil = (x: unknown): x is null | undefined => x == undefined;\n\n// Type Guard to determine if a given key is actually a key of some object of type T\nexport const isKeyOf = <T = unknown>(k: KeyTypes, o: T): k is keyof T => {\n  if (isNil(o)) return false;\n  return k in o;\n};\n\nconst toKebabCase = (string: string) => string.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);\n\nexport const toNativeAttrName = (propName: string, propValue: any): string | undefined => {\n  if (typeof propValue === 'boolean' && !propValue) return undefined;\n  if (isKeyOf(propName, ReactPropToAttrNameMap)) return ReactPropToAttrNameMap[propName];\n  if (typeof propValue == undefined) return undefined;\n  if (/[A-Z]/.test(propName)) return toKebabCase(propName);\n  return propName;\n};\nexport const toStyleAttr = <T>(x: T) => x;\n\nexport const toNativeAttrValue = (propValue: any, propName: string) => {\n  if (typeof propValue === 'boolean') return '';\n  return propValue;\n};\n\nexport const toNativeProps = (props = {}) => {\n  return Object.entries(props).reduce<{ [k: string]: string }>((transformedProps, [propName, propValue]) => {\n    const attrName = toNativeAttrName(propName, propValue);\n\n    // prop was stripped. Don't add.\n    if (!attrName) {\n      return transformedProps;\n    }\n\n    const attrValue = toNativeAttrValue(propValue, propName);\n    transformedProps[attrName] = attrValue;\n    return transformedProps;\n  }, {});\n};\n", "import { useEffect, useRef } from 'react';\nimport type { MutableRefObject, ForwardedRef } from 'react';\n\ntype Maybe<T> = T | null | undefined;\ntype RefCb<T> = (instance: Maybe<T>) => void;\ntype RefObj<T> = MutableRefObject<Maybe<T>>;\ntype RefTypes<T> = RefObj<T> | RefCb<T> | ForwardedRef<T>;\ninterface useCombinedRefs {\n  <T>(...refs: Maybe<RefTypes<T>>[]): RefObj<T>;\n}\n\nexport const useCombinedRefs: useCombinedRefs = (...refs) => {\n  const targetRef = useRef(null);\n\n  useEffect(() => {\n    refs.forEach((ref) => {\n      if (!ref) return;\n\n      if (typeof ref === 'function') {\n        ref(targetRef.current);\n      } else {\n        ref.current = targetRef.current;\n      }\n    });\n  }, [refs]);\n\n  return targetRef;\n};\n\nexport default useCombinedRefs;\n", "import { useEffect } from 'react';\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Slightly modified version of React's shallowEqual, with optimizations for Arrays\n * so we may treat them specifically as unequal if they are not a) both arrays\n * or b) don't contain the same (shallowly compared) elements.\n */\nconst shallowEqual = (objA: any, objB: any): boolean => {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  if (Array.isArray(objA)) {\n    // Early \"cheap\" array compares\n    if (!Array.isArray(objB) || objA.length !== objB.length) return false;\n    // Shallow compare for arrays\n    return objA.some((vVal, i) => objB[i] === vVal);\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (let i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexport const defaultHasChanged = (obj: any, v: any, k: string) => {\n  return !shallowEqual(v, obj[k]);\n};\n\nconst defaultUpdateValue = (obj: any, v: any, k: string) => {\n  obj[k] = v;\n};\n\nexport const useObjectPropEffect = <T extends { [k: string]: any }, V>(\n  propName: string,\n  propValue: V | null | undefined,\n  ref: React.MutableRefObject<T | null> | null | undefined,\n  updateValue = defaultUpdateValue,\n  hasChanged = defaultHasChanged\n) => {\n  return useEffect(() => {\n    const obj = ref?.current;\n    if (!obj) return;\n    if (!hasChanged(obj, propValue, propName)) return;\n    updateValue(obj, propValue, propName);\n  }, [ref?.current, propValue]);\n};\n\nexport default useObjectPropEffect;\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "mux_uploader_drop_default", "src_default", "__toCommonJS", "import_react", "Ce", "R", "Rt", "ye", "T", "Se", "Tt", "Ee", "ut", "ot", "t", "e", "ve", "zt", "ke", "D", "lt", "n", "r", "i", "a", "o", "s", "Re", "_t", "we", "ht", "ct", "Pe", "Pt", "M", "Te", "pt", "dt", "ft", "C", "yt", "mt", "ze", "_e", "gt", "S", "z", "Be", "u", "bt", "$", "I", "V", "h", "d", "p", "c", "y", "f", "O", "N", "ie", "se", "G", "Xe", "m", "Y", "g", "He", "We", "$e", "Ve", "qe", "Ge", "L", "K", "vt", "b", "Z", "J", "Q", "ee", "F", "l", "te", "B", "Ye", "v", "ae", "re", "ne", "w", "ue", "oe", "le", "E", "_", "Ke", "Ze", "Je", "ce", "he", "pe", "Qe", "et", "de", "tt", "fe", "me", "nt", "rt", "k", "ge", "x", "it", "at", "st", "be", "U", "Ae", "je", "Oe", "P", "A", "j", "X", "H", "Ct", "Ie", "Le", "Et", "St", "W", "It", "EventTarget", "_event", "DocumentFragment", "HTMLElement", "HTMLVideoElement", "customElements", "_name", "_constructor", "_options", "_root", "_detail", "CustomEvent", "typeArg", "eventInitDict", "__privateAdd", "__privateSet", "__privateGet", "createElement", "_tagName", "globalThisShim", "isServer", "GlobalThis", "Document", "template", "Attributes", "MuxUploaderDropElement", "shadowRoot", "attributeName", "oldValue", "newValue", "uploaderId", "evt", "_a", "dataTransfer", "files", "file", "styles", "TYPES", "defaultFormatProgress", "percent", "getRadius", "el", "getCircumference", "ariaDescription", "ButtonPressedKeys", "MuxUploaderElement", "_b", "_c", "_d", "_e", "_f", "_g", "_h", "_i", "_j", "_k", "shadow", "uploaderHtml", "value", "currentType", "keyUpHandler", "e", "key", "metaKey", "altKey", "offset", "endpoint", "dynamicChunkSize", "invalidUrlMessage", "upload", "It", "event", "errorMessage", "successMessage", "import_react", "ReactPropToAttrNameMap", "isNil", "x", "isKeyOf", "k", "o", "toKebabCase", "string", "match", "toNativeAttrName", "propName", "propValue", "toNativeAttrValue", "propValue", "propName", "toNativeProps", "props", "transformedProps", "attrName", "toNativeAttrName", "attrValue", "import_react", "import_react", "useCombinedRefs", "refs", "targetRef", "ref", "MuxUploaderDropInternal", "React", "children", "props", "ref", "toNativeProps", "MuxUploaderDrop", "innerUploaderDropRef", "uploaderDropRef", "useCombinedRefs", "mux_uploader_drop_default", "import_react", "import_react", "hasOwnProperty", "shallowEqual", "objA", "objB", "vVal", "i", "keysA", "keysB", "defaultHasChanged", "obj", "v", "k", "defaultUpdateValue", "useObjectPropEffect", "propName", "propValue", "ref", "updateValue", "hasChanged", "useObjectPropEffect_default", "MuxUploaderInternal", "React", "children", "props", "ref", "toNativeProps", "useEventCallbackEffect", "type", "callback", "eventTarget", "useUploader", "onUploadStart", "onChunkAttempt", "onChunkSuccess", "onUploadError", "onProgress", "onSuccess", "formatProgress", "endpoint", "remainingProps", "useObjectPropEffect_default", "MuxUploader", "innerUploaderRef", "uploaderRef", "useCombinedRefs", "src_default", "MuxUploader"]
}
